{"ast":null,"code":"import _objectWithoutProperties from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nvar _excluded = [\"keyframes\", \"restDelta\", \"restSpeed\"];\nimport { millisecondsToSeconds } from '../../../utils/time-conversion.mjs';\nimport { calcGeneratorVelocity } from '../utils/velocity.mjs';\nimport { findSpring, calcAngularFreq } from './find.mjs';\nvar durationKeys = [\"duration\", \"bounce\"];\nvar physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\n\nfunction isSpringType(options, keys) {\n  return keys.some(function (key) {\n    return options[key] !== undefined;\n  });\n}\n\nfunction getSpringOptions(options) {\n  var springOptions = _objectSpread({\n    velocity: 0.0,\n    stiffness: 100,\n    damping: 10,\n    mass: 1.0,\n    isResolvedFromDuration: false\n  }, options); // stiffness/damping/mass overrides duration/bounce\n\n\n  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {\n    var derived = findSpring(options);\n    springOptions = _objectSpread(_objectSpread(_objectSpread({}, springOptions), derived), {}, {\n      mass: 1.0\n    });\n    springOptions.isResolvedFromDuration = true;\n  }\n\n  return springOptions;\n}\n\nfunction spring(_ref) {\n  var keyframes = _ref.keyframes,\n      restDelta = _ref.restDelta,\n      restSpeed = _ref.restSpeed,\n      options = _objectWithoutProperties(_ref, _excluded);\n\n  var origin = keyframes[0];\n  var target = keyframes[keyframes.length - 1];\n  /**\n   * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n   * to reduce GC during animation.\n   */\n\n  var state = {\n    done: false,\n    value: origin\n  };\n\n  var _getSpringOptions = getSpringOptions(_objectSpread(_objectSpread({}, options), {}, {\n    velocity: -millisecondsToSeconds(options.velocity || 0)\n  })),\n      stiffness = _getSpringOptions.stiffness,\n      damping = _getSpringOptions.damping,\n      mass = _getSpringOptions.mass,\n      duration = _getSpringOptions.duration,\n      velocity = _getSpringOptions.velocity,\n      isResolvedFromDuration = _getSpringOptions.isResolvedFromDuration;\n\n  var initialVelocity = velocity || 0.0;\n  var dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n  var initialDelta = target - origin;\n  var undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));\n  /**\n   * If we're working on a granular scale, use smaller defaults for determining\n   * when the spring is finished.\n   *\n   * These defaults have been selected emprically based on what strikes a good\n   * ratio between feeling good and finishing as soon as changes are imperceptible.\n   */\n\n  var isGranularScale = Math.abs(initialDelta) < 5;\n  restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);\n  restDelta || (restDelta = isGranularScale ? 0.005 : 0.5);\n  var resolveSpring;\n\n  if (dampingRatio < 1) {\n    var angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio); // Underdamped spring\n\n    resolveSpring = function resolveSpring(t) {\n      var envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));\n    };\n  } else if (dampingRatio === 1) {\n    // Critically damped spring\n    resolveSpring = function resolveSpring(t) {\n      return target - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    };\n  } else {\n    // Overdamped spring\n    var dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n\n    resolveSpring = function resolveSpring(t) {\n      var envelope = Math.exp(-dampingRatio * undampedAngularFreq * t); // When performing sinh or cosh values can hit Infinity so we cap them here\n\n      var freqForT = Math.min(dampedAngularFreq * t, 300);\n      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;\n    };\n  }\n\n  return {\n    calculatedDuration: isResolvedFromDuration ? duration || null : null,\n    next: function next(t) {\n      var current = resolveSpring(t);\n\n      if (!isResolvedFromDuration) {\n        var currentVelocity = initialVelocity;\n\n        if (t !== 0) {\n          /**\n           * We only need to calculate velocity for under-damped springs\n           * as over- and critically-damped springs can't overshoot, so\n           * checking only for displacement is enough.\n           */\n          if (dampingRatio < 1) {\n            currentVelocity = calcGeneratorVelocity(resolveSpring, t, current);\n          } else {\n            currentVelocity = 0;\n          }\n        }\n\n        var isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n        var isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;\n      } else {\n        state.done = t >= duration;\n      }\n\n      state.value = state.done ? target : current;\n      return state;\n    }\n  };\n}\n\nexport { spring };","map":null,"metadata":{},"sourceType":"module"}