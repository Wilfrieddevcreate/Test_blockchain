{"ast":null,"code":"import _objectWithoutProperties from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _classCallCheck from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _objectSpread from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nvar _excluded = [\"onComplete\", \"onUpdate\", \"motionValue\"],\n    _excluded2 = [\"motionValue\", \"onUpdate\", \"onComplete\"];\nimport { time } from '../../frameloop/sync-time.mjs';\nimport { DOMKeyframesResolver } from '../../render/dom/DOMKeyframesResolver.mjs';\nimport { memo } from '../../utils/memo.mjs';\nimport { noop } from '../../utils/noop.mjs';\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { BaseAnimation } from './BaseAnimation.mjs';\nimport { MainThreadAnimation } from './MainThreadAnimation.mjs';\nimport { animateStyle } from './waapi/index.mjs';\nimport { isWaapiSupportedEasing } from './waapi/easing.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\nvar supportsWaapi = memo(function () {\n  return Object.hasOwnProperty.call(Element.prototype, \"animate\");\n});\n/**\n * A list of values that can be hardware-accelerated.\n */\n\nvar acceleratedValues = new Set([\"opacity\", \"clipPath\", \"filter\", \"transform\" // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved\n// or until we implement support for linear() easing.\n// \"background-color\"\n]);\n/**\n * 10ms is chosen here as it strikes a balance between smooth\n * results (more than one keyframe per frame at 60fps) and\n * keyframe quantity.\n */\n\nvar sampleDelta = 10; //ms\n\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\n\nvar maxDuration = 20000;\n/**\n * Check if an animation can run natively via WAAPI or requires pregenerated keyframes.\n * WAAPI doesn't support spring or function easings so we run these as JS animation before\n * handing off.\n */\n\nfunction requiresPregeneratedKeyframes(options) {\n  return options.type === \"spring\" || options.name === \"backgroundColor\" || !isWaapiSupportedEasing(options.ease);\n}\n\nfunction pregenerateKeyframes(keyframes, options) {\n  /**\n   * Create a main-thread animation to pregenerate keyframes.\n   * We sample this at regular intervals to generate keyframes that we then\n   * linearly interpolate between.\n   */\n  var sampleAnimation = new MainThreadAnimation(_objectSpread(_objectSpread({}, options), {}, {\n    keyframes: keyframes,\n    repeat: 0,\n    delay: 0,\n    isGenerator: true\n  }));\n  var state = {\n    done: false,\n    value: keyframes[0]\n  };\n  var pregeneratedKeyframes = [];\n  /**\n   * Bail after 20 seconds of pre-generated keyframes as it's likely\n   * we're heading for an infinite loop.\n   */\n\n  var t = 0;\n\n  while (!state.done && t < maxDuration) {\n    state = sampleAnimation.sample(t);\n    pregeneratedKeyframes.push(state.value);\n    t += sampleDelta;\n  }\n\n  return {\n    times: undefined,\n    keyframes: pregeneratedKeyframes,\n    duration: t - sampleDelta,\n    ease: \"linear\"\n  };\n}\n\nvar AcceleratedAnimation = /*#__PURE__*/function (_BaseAnimation) {\n  _inherits(AcceleratedAnimation, _BaseAnimation);\n\n  var _super = _createSuper(AcceleratedAnimation);\n\n  function AcceleratedAnimation(options) {\n    var _this;\n\n    _classCallCheck(this, AcceleratedAnimation);\n\n    _this = _super.call(this, options);\n    var _this$options = _this.options,\n        name = _this$options.name,\n        motionValue = _this$options.motionValue,\n        keyframes = _this$options.keyframes;\n    _this.resolver = new DOMKeyframesResolver(keyframes, function (resolvedKeyframes, finalKeyframe) {\n      return _this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);\n    }, name, motionValue);\n\n    _this.resolver.scheduleResolve();\n\n    return _this;\n  }\n\n  _createClass(AcceleratedAnimation, [{\n    key: \"initPlayback\",\n    value: function initPlayback(keyframes, finalKeyframe) {\n      var _this2 = this;\n\n      var _a;\n\n      var _this$options2 = this.options,\n          _this$options2$durati = _this$options2.duration,\n          duration = _this$options2$durati === void 0 ? 300 : _this$options2$durati,\n          times = _this$options2.times,\n          ease = _this$options2.ease,\n          type = _this$options2.type,\n          motionValue = _this$options2.motionValue,\n          name = _this$options2.name;\n      /**\n       * If element has since been unmounted, return false to indicate\n       * the animation failed to initialised.\n       */\n\n      if (!((_a = motionValue.owner) === null || _a === void 0 ? void 0 : _a.current)) {\n        return false;\n      }\n      /**\n       * If this animation needs pre-generated keyframes then generate.\n       */\n\n\n      if (requiresPregeneratedKeyframes(this.options)) {\n        var _this$options3 = this.options,\n            onComplete = _this$options3.onComplete,\n            onUpdate = _this$options3.onUpdate,\n            _motionValue = _this$options3.motionValue,\n            options = _objectWithoutProperties(_this$options3, _excluded);\n\n        var pregeneratedAnimation = pregenerateKeyframes(keyframes, options);\n        keyframes = pregeneratedAnimation.keyframes; // If this is a very short animation, ensure we have\n        // at least two keyframes to animate between as older browsers\n        // can't animate between a single keyframe.\n\n        if (keyframes.length === 1) {\n          keyframes[1] = keyframes[0];\n        }\n\n        duration = pregeneratedAnimation.duration;\n        times = pregeneratedAnimation.times;\n        ease = pregeneratedAnimation.ease;\n        type = \"keyframes\";\n      }\n\n      var animation = animateStyle(motionValue.owner.current, name, keyframes, _objectSpread(_objectSpread({}, this.options), {}, {\n        duration: duration,\n        times: times,\n        ease: ease\n      })); // Override the browser calculated startTime with one synchronised to other JS\n      // and WAAPI animations starting this event loop.\n\n      animation.startTime = time.now();\n\n      if (this.pendingTimeline) {\n        animation.timeline = this.pendingTimeline;\n        this.pendingTimeline = undefined;\n      } else {\n        /**\n         * Prefer the `onfinish` prop as it's more widely supported than\n         * the `finished` promise.\n         *\n         * Here, we synchronously set the provided MotionValue to the end\n         * keyframe. If we didn't, when the WAAPI animation is finished it would\n         * be removed from the element which would then revert to its old styles.\n         */\n        animation.onfinish = function () {\n          var onComplete = _this2.options.onComplete;\n          motionValue.set(getFinalKeyframe(keyframes, _this2.options, finalKeyframe));\n          onComplete && onComplete();\n\n          _this2.cancel();\n\n          _this2.resolveFinishedPromise();\n        };\n      }\n\n      return {\n        animation: animation,\n        duration: duration,\n        times: times,\n        type: type,\n        ease: ease,\n        keyframes: keyframes\n      };\n    }\n  }, {\n    key: \"duration\",\n    get: function get() {\n      var resolved = this.resolved;\n      if (!resolved) return 0;\n      var duration = resolved.duration;\n      return millisecondsToSeconds(duration);\n    }\n  }, {\n    key: \"time\",\n    get: function get() {\n      var resolved = this.resolved;\n      if (!resolved) return 0;\n      var animation = resolved.animation;\n      return millisecondsToSeconds(animation.currentTime || 0);\n    },\n    set: function set(newTime) {\n      var resolved = this.resolved;\n      if (!resolved) return;\n      var animation = resolved.animation;\n      animation.currentTime = secondsToMilliseconds(newTime);\n    }\n  }, {\n    key: \"speed\",\n    get: function get() {\n      var resolved = this.resolved;\n      if (!resolved) return 1;\n      var animation = resolved.animation;\n      return animation.playbackRate;\n    },\n    set: function set(newSpeed) {\n      var resolved = this.resolved;\n      if (!resolved) return;\n      var animation = resolved.animation;\n      animation.playbackRate = newSpeed;\n    }\n  }, {\n    key: \"state\",\n    get: function get() {\n      var resolved = this.resolved;\n      if (!resolved) return \"idle\";\n      var animation = resolved.animation;\n      return animation.playState;\n    }\n    /**\n     * Replace the default DocumentTimeline with another AnimationTimeline.\n     * Currently used for scroll animations.\n     */\n\n  }, {\n    key: \"attachTimeline\",\n    value: function attachTimeline(timeline) {\n      if (!this._resolved) {\n        this.pendingTimeline = timeline;\n      } else {\n        var resolved = this.resolved;\n        if (!resolved) return noop;\n        var animation = resolved.animation;\n        animation.timeline = timeline;\n        animation.onfinish = null;\n      }\n\n      return noop;\n    }\n  }, {\n    key: \"play\",\n    value: function play() {\n      if (this.isStopped) return;\n      var resolved = this.resolved;\n      if (!resolved) return;\n      var animation = resolved.animation;\n\n      if (animation.playState === \"finished\") {\n        this.updateFinishedPromise();\n      }\n\n      animation.play();\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      var resolved = this.resolved;\n      if (!resolved) return;\n      var animation = resolved.animation;\n      animation.pause();\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.resolver.cancel();\n      this.isStopped = true;\n      if (this.state === \"idle\") return;\n      var resolved = this.resolved;\n      if (!resolved) return;\n      var animation = resolved.animation,\n          keyframes = resolved.keyframes,\n          duration = resolved.duration,\n          type = resolved.type,\n          ease = resolved.ease,\n          times = resolved.times;\n\n      if (animation.playState === \"idle\" || animation.playState === \"finished\") {\n        return;\n      }\n      /**\n       * WAAPI doesn't natively have any interruption capabilities.\n       *\n       * Rather than read commited styles back out of the DOM, we can\n       * create a renderless JS animation and sample it twice to calculate\n       * its current value, \"previous\" value, and therefore allow\n       * Motion to calculate velocity for any subsequent animation.\n       */\n\n\n      if (this.time) {\n        var _this$options4 = this.options,\n            motionValue = _this$options4.motionValue,\n            onUpdate = _this$options4.onUpdate,\n            onComplete = _this$options4.onComplete,\n            options = _objectWithoutProperties(_this$options4, _excluded2);\n\n        var sampleAnimation = new MainThreadAnimation(_objectSpread(_objectSpread({}, options), {}, {\n          keyframes: keyframes,\n          duration: duration,\n          type: type,\n          ease: ease,\n          times: times,\n          isGenerator: true\n        }));\n        var sampleTime = secondsToMilliseconds(this.time);\n        motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);\n      }\n\n      this.cancel();\n    }\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      var resolved = this.resolved;\n      if (!resolved) return;\n      resolved.animation.finish();\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      var resolved = this.resolved;\n      if (!resolved) return;\n      resolved.animation.cancel();\n    }\n  }], [{\n    key: \"supports\",\n    value: function supports(options) {\n      var motionValue = options.motionValue,\n          name = options.name,\n          repeatDelay = options.repeatDelay,\n          repeatType = options.repeatType,\n          damping = options.damping,\n          type = options.type;\n      return supportsWaapi() && name && acceleratedValues.has(name) && motionValue && motionValue.owner && motionValue.owner.current instanceof HTMLElement &&\n      /**\n       * If we're outputting values to onUpdate then we can't use WAAPI as there's\n       * no way to read the value from WAAPI every frame.\n       */\n      !motionValue.owner.getProps().onUpdate && !repeatDelay && repeatType !== \"mirror\" && damping !== 0 && type !== \"inertia\";\n    }\n  }]);\n\n  return AcceleratedAnimation;\n}(BaseAnimation);\n\nexport { AcceleratedAnimation };","map":null,"metadata":{},"sourceType":"module"}