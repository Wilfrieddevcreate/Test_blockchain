{"ast":null,"code":"import { color } from '../color/index.mjs';\nimport { isString, floatRegex, colorRegex, sanitize } from '../utils.mjs';\n\nfunction test(v) {\n  var _a, _b;\n\n  return isNaN(v) && isString(v) && (((_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) + (((_b = v.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) > 0;\n}\n\nvar NUMBER_TOKEN = \"number\";\nvar COLOR_TOKEN = \"color\";\nvar VAR_TOKEN = \"var\";\nvar VAR_FUNCTION_TOKEN = \"var(\";\nvar SPLIT_TOKEN = \"${}\"; // this regex consists of the `singleCssVariableRegex|rgbHSLValueRegex|digitRegex`\n\nvar complexRegex = /var[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]*\\([\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]*\\x2D\\x2D(?:[\\x2D0-9A-Z_a-z\\u017F\\u212A]+[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]*|[\\x2D0-9A-Z_a-z\\u017F\\u212A]+[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]*,(?:[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]*(?:(?![\\t-\\r \\(\\)\\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF])[\\s\\S])|[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]*\\((?:(?:(?![\\(\\)])[\\s\\S])|\\((?:(?![\\(\\)])[\\s\\S])*\\))*\\))+[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]*)\\)|#[0-9a-f]{3,8}|(?:rgb|h[s\\u017F]l)a?\\((?:\\x2D?[\\.0-9]+%?[\\t-\\r ,\\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]+){2}\\x2D?[\\.0-9]+%?[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]*(?:[,\\/][\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]*)?(?:\\b[0-9]+(?:\\.[0-9]+)?|\\.[0-9]+)?%?\\)|\\x2D?(?:[0-9]+(?:\\.[0-9]+)?|\\.[0-9]+)/gi;\n\nfunction analyseComplexValue(value) {\n  var originalValue = value.toString();\n  var values = [];\n  var indexes = {\n    color: [],\n    number: [],\n    var: []\n  };\n  var types = [];\n  var i = 0;\n  var tokenised = originalValue.replace(complexRegex, function (parsedValue) {\n    if (color.test(parsedValue)) {\n      indexes.color.push(i);\n      types.push(COLOR_TOKEN);\n      values.push(color.parse(parsedValue));\n    } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {\n      indexes.var.push(i);\n      types.push(VAR_TOKEN);\n      values.push(parsedValue);\n    } else {\n      indexes.number.push(i);\n      types.push(NUMBER_TOKEN);\n      values.push(parseFloat(parsedValue));\n    }\n\n    ++i;\n    return SPLIT_TOKEN;\n  });\n  var split = tokenised.split(SPLIT_TOKEN);\n  return {\n    values: values,\n    split: split,\n    indexes: indexes,\n    types: types\n  };\n}\n\nfunction parseComplexValue(v) {\n  return analyseComplexValue(v).values;\n}\n\nfunction createTransformer(source) {\n  var _analyseComplexValue = analyseComplexValue(source),\n      split = _analyseComplexValue.split,\n      types = _analyseComplexValue.types;\n\n  var numSections = split.length;\n  return function (v) {\n    var output = \"\";\n\n    for (var i = 0; i < numSections; i++) {\n      output += split[i];\n\n      if (v[i] !== undefined) {\n        var type = types[i];\n\n        if (type === NUMBER_TOKEN) {\n          output += sanitize(v[i]);\n        } else if (type === COLOR_TOKEN) {\n          output += color.transform(v[i]);\n        } else {\n          output += v[i];\n        }\n      }\n    }\n\n    return output;\n  };\n}\n\nvar convertNumbersToZero = function convertNumbersToZero(v) {\n  return typeof v === \"number\" ? 0 : v;\n};\n\nfunction getAnimatableNone(v) {\n  var parsed = parseComplexValue(v);\n  var transformer = createTransformer(v);\n  return transformer(parsed.map(convertNumbersToZero));\n}\n\nvar complex = {\n  test: test,\n  parse: parseComplexValue,\n  createTransformer: createTransformer,\n  getAnimatableNone: getAnimatableNone\n};\nexport { analyseComplexValue, complex };","map":null,"metadata":{},"sourceType":"module"}