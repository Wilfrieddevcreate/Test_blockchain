{"ast":null,"code":"import _objectSpread from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _classCallCheck from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar _excluded = [\"autoplay\", \"delay\", \"type\", \"repeat\", \"repeatDelay\", \"repeatType\"];\nimport { flushKeyframeResolvers } from '../../render/utils/KeyframesResolver.mjs';\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\nimport { canAnimate } from './utils/can-animate.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\n\nvar BaseAnimation = /*#__PURE__*/function () {\n  function BaseAnimation(_ref) {\n    var _ref$autoplay = _ref.autoplay,\n        autoplay = _ref$autoplay === void 0 ? true : _ref$autoplay,\n        _ref$delay = _ref.delay,\n        delay = _ref$delay === void 0 ? 0 : _ref$delay,\n        _ref$type = _ref.type,\n        type = _ref$type === void 0 ? \"keyframes\" : _ref$type,\n        _ref$repeat = _ref.repeat,\n        repeat = _ref$repeat === void 0 ? 0 : _ref$repeat,\n        _ref$repeatDelay = _ref.repeatDelay,\n        repeatDelay = _ref$repeatDelay === void 0 ? 0 : _ref$repeatDelay,\n        _ref$repeatType = _ref.repeatType,\n        repeatType = _ref$repeatType === void 0 ? \"loop\" : _ref$repeatType,\n        options = _objectWithoutProperties(_ref, _excluded);\n\n    _classCallCheck(this, BaseAnimation);\n\n    // Track whether the animation has been stopped. Stopped animations won't restart.\n    this.isStopped = false;\n    this.hasAttemptedResolve = false;\n    this.options = _objectSpread({\n      autoplay: autoplay,\n      delay: delay,\n      type: type,\n      repeat: repeat,\n      repeatDelay: repeatDelay,\n      repeatType: repeatType\n    }, options);\n    this.updateFinishedPromise();\n  }\n  /**\n   * A getter for resolved data. If keyframes are not yet resolved, accessing\n   * this.resolved will synchronously flush all pending keyframe resolvers.\n   * This is a deoptimisation, but at its worst still batches read/writes.\n   */\n\n\n  _createClass(BaseAnimation, [{\n    key: \"resolved\",\n    get: function get() {\n      if (!this._resolved && !this.hasAttemptedResolve) {\n        flushKeyframeResolvers();\n      }\n\n      return this._resolved;\n    }\n    /**\n     * A method to be called when the keyframes resolver completes. This method\n     * will check if its possible to run the animation and, if not, skip it.\n     * Otherwise, it will call initPlayback on the implementing class.\n     */\n\n  }, {\n    key: \"onKeyframesResolved\",\n    value: function onKeyframesResolved(keyframes, finalKeyframe) {\n      this.hasAttemptedResolve = true;\n      var _this$options = this.options,\n          name = _this$options.name,\n          type = _this$options.type,\n          velocity = _this$options.velocity,\n          delay = _this$options.delay,\n          onComplete = _this$options.onComplete,\n          onUpdate = _this$options.onUpdate,\n          isGenerator = _this$options.isGenerator;\n      /**\n       * If we can't animate this value with the resolved keyframes\n       * then we should complete it immediately.\n       */\n\n      if (!isGenerator && !canAnimate(keyframes, name, type, velocity)) {\n        // Finish immediately\n        if (instantAnimationState.current || !delay) {\n          onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n          onComplete === null || onComplete === void 0 ? void 0 : onComplete();\n          this.resolveFinishedPromise();\n          return;\n        } // Finish after a delay\n        else {\n          this.options.duration = 0;\n        }\n      }\n\n      var resolvedAnimation = this.initPlayback(keyframes, finalKeyframe);\n      if (resolvedAnimation === false) return;\n      this._resolved = _objectSpread({\n        keyframes: keyframes,\n        finalKeyframe: finalKeyframe\n      }, resolvedAnimation);\n      this.onPostResolved();\n    }\n  }, {\n    key: \"onPostResolved\",\n    value: function onPostResolved() {}\n    /**\n     * Allows the returned animation to be awaited or promise-chained. Currently\n     * resolves when the animation finishes at all but in a future update could/should\n     * reject if its cancels.\n     */\n\n  }, {\n    key: \"then\",\n    value: function then(resolve, reject) {\n      return this.currentFinishedPromise.then(resolve, reject);\n    }\n  }, {\n    key: \"updateFinishedPromise\",\n    value: function updateFinishedPromise() {\n      var _this = this;\n\n      this.currentFinishedPromise = new Promise(function (resolve) {\n        _this.resolveFinishedPromise = resolve;\n      });\n    }\n  }]);\n\n  return BaseAnimation;\n}();\n\nexport { BaseAnimation };","map":null,"metadata":{},"sourceType":"module"}