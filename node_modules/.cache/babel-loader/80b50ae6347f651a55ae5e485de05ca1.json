{"ast":null,"code":"import _toConsumableArray from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _classCallCheck from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nvar _excluded = [\"KeyframeResolver\"];\nimport { KeyframeResolver } from '../../render/utils/KeyframesResolver.mjs';\nimport { spring } from '../generators/spring/index.mjs';\nimport { inertia } from '../generators/inertia.mjs';\nimport { keyframes } from '../generators/keyframes.mjs';\nimport { BaseAnimation } from './BaseAnimation.mjs';\nimport { pipe } from '../../utils/pipe.mjs';\nimport { mix } from '../../utils/mix/index.mjs';\nimport { calcGeneratorDuration } from '../generators/utils/calc-duration.mjs';\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { clamp } from '../../utils/clamp.mjs';\nimport { invariant } from '../../utils/errors.mjs';\nimport { frameloopDriver } from './drivers/driver-frameloop.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\nvar generators = {\n  decay: inertia,\n  inertia: inertia,\n  tween: keyframes,\n  keyframes: keyframes,\n  spring: spring\n};\n\nvar percentToProgress = function percentToProgress(percent) {\n  return percent / 100;\n};\n/**\n * Animation that runs on the main thread. Designed to be WAAPI-spec in the subset of\n * features we expose publically. Mostly the compatibility is to ensure visual identity\n * between both WAAPI and main thread animations.\n */\n\n\nvar MainThreadAnimation = /*#__PURE__*/function (_BaseAnimation) {\n  _inherits(MainThreadAnimation, _BaseAnimation);\n\n  var _super = _createSuper(MainThreadAnimation);\n\n  function MainThreadAnimation(_ref) {\n    var _this;\n\n    var _ref$KeyframeResolver = _ref.KeyframeResolver,\n        KeyframeResolver$1 = _ref$KeyframeResolver === void 0 ? KeyframeResolver : _ref$KeyframeResolver,\n        options = _objectWithoutProperties(_ref, _excluded);\n\n    _classCallCheck(this, MainThreadAnimation);\n\n    _this = _super.call(this, options);\n    /**\n     * The time at which the animation was paused.\n     */\n\n    _this.holdTime = null;\n    /**\n     * The time at which the animation was started.\n     */\n\n    _this.startTime = null;\n    /**\n     * The time at which the animation was cancelled.\n     */\n\n    _this.cancelTime = null;\n    /**\n     * The current time of the animation.\n     */\n\n    _this.currentTime = 0;\n    /**\n     * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\n     */\n\n    _this.playbackSpeed = 1;\n    /**\n     * The state of the animation to apply when the animation is resolved. This\n     * allows calls to the public API to control the animation before it is resolved,\n     * without us having to resolve it first.\n     */\n\n    _this.pendingPlayState = \"running\";\n    _this.state = \"idle\";\n    /**\n     * This method is bound to the instance to fix a pattern where\n     * animation.stop is returned as a reference from a useEffect.\n     */\n\n    _this.stop = function () {\n      _this.resolver.cancel();\n\n      _this.isStopped = true;\n      if (_this.state === \"idle\") return;\n\n      _this.teardown();\n\n      var onStop = _this.options.onStop;\n      onStop && onStop();\n    };\n\n    var _this$options = _this.options,\n        name = _this$options.name,\n        motionValue = _this$options.motionValue,\n        keyframes = _this$options.keyframes;\n\n    var onResolved = function onResolved(resolvedKeyframes, finalKeyframe) {\n      return _this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);\n    };\n\n    if (name && motionValue && motionValue.owner) {\n      _this.resolver = motionValue.owner.resolveKeyframes(keyframes, onResolved, name, motionValue);\n    } else {\n      _this.resolver = new KeyframeResolver$1(keyframes, onResolved, name, motionValue);\n    }\n\n    _this.resolver.scheduleResolve();\n\n    return _this;\n  }\n\n  _createClass(MainThreadAnimation, [{\n    key: \"initPlayback\",\n    value: function initPlayback(keyframes$1) {\n      var _this$options2 = this.options,\n          _this$options2$type = _this$options2.type,\n          type = _this$options2$type === void 0 ? \"keyframes\" : _this$options2$type,\n          _this$options2$repeat = _this$options2.repeat,\n          repeat = _this$options2$repeat === void 0 ? 0 : _this$options2$repeat,\n          _this$options2$repeat2 = _this$options2.repeatDelay,\n          repeatDelay = _this$options2$repeat2 === void 0 ? 0 : _this$options2$repeat2,\n          repeatType = _this$options2.repeatType,\n          _this$options2$veloci = _this$options2.velocity,\n          velocity = _this$options2$veloci === void 0 ? 0 : _this$options2$veloci;\n      var generatorFactory = generators[type] || keyframes;\n      /**\n       * If our generator doesn't support mixing numbers, we need to replace keyframes with\n       * [0, 100] and then make a function that maps that to the actual keyframes.\n       *\n       * 100 is chosen instead of 1 as it works nicer with spring animations.\n       */\n\n      var mapPercentToKeyframes;\n      var mirroredGenerator;\n\n      if (generatorFactory !== keyframes && typeof keyframes$1[0] !== \"number\") {\n        if (process.env.NODE_ENV !== \"production\") {\n          invariant(keyframes$1.length === 2, \"Only two keyframes currently supported with spring and inertia animations. Trying to animate \".concat(keyframes$1));\n        }\n\n        mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));\n        keyframes$1 = [0, 100];\n      }\n\n      var generator = generatorFactory(_objectSpread(_objectSpread({}, this.options), {}, {\n        keyframes: keyframes$1\n      }));\n      /**\n       * If we have a mirror repeat type we need to create a second generator that outputs the\n       * mirrored (not reversed) animation and later ping pong between the two generators.\n       */\n\n      if (repeatType === \"mirror\") {\n        mirroredGenerator = generatorFactory(_objectSpread(_objectSpread({}, this.options), {}, {\n          keyframes: _toConsumableArray(keyframes$1).reverse(),\n          velocity: -velocity\n        }));\n      }\n      /**\n       * If duration is undefined and we have repeat options,\n       * we need to calculate a duration from the generator.\n       *\n       * We set it to the generator itself to cache the duration.\n       * Any timeline resolver will need to have already precalculated\n       * the duration by this step.\n       */\n\n\n      if (generator.calculatedDuration === null) {\n        generator.calculatedDuration = calcGeneratorDuration(generator);\n      }\n\n      var calculatedDuration = generator.calculatedDuration;\n      var resolvedDuration = calculatedDuration + repeatDelay;\n      var totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\n      return {\n        generator: generator,\n        mirroredGenerator: mirroredGenerator,\n        mapPercentToKeyframes: mapPercentToKeyframes,\n        calculatedDuration: calculatedDuration,\n        resolvedDuration: resolvedDuration,\n        totalDuration: totalDuration\n      };\n    }\n  }, {\n    key: \"onPostResolved\",\n    value: function onPostResolved() {\n      var _this$options$autopla = this.options.autoplay,\n          autoplay = _this$options$autopla === void 0 ? true : _this$options$autopla;\n      this.play();\n\n      if (this.pendingPlayState === \"paused\" || !autoplay) {\n        this.pause();\n      } else {\n        this.state = this.pendingPlayState;\n      }\n    }\n  }, {\n    key: \"tick\",\n    value: function tick(timestamp) {\n      var sample = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var resolved = this.resolved; // If the animations has failed to resolve, return the final keyframe.\n\n      if (!resolved) {\n        var _keyframes = this.options.keyframes;\n        return {\n          done: true,\n          value: _keyframes[_keyframes.length - 1]\n        };\n      }\n\n      var finalKeyframe = resolved.finalKeyframe,\n          generator = resolved.generator,\n          mirroredGenerator = resolved.mirroredGenerator,\n          mapPercentToKeyframes = resolved.mapPercentToKeyframes,\n          keyframes = resolved.keyframes,\n          calculatedDuration = resolved.calculatedDuration,\n          totalDuration = resolved.totalDuration,\n          resolvedDuration = resolved.resolvedDuration;\n      if (this.startTime === null) return generator.next(0);\n      var _this$options3 = this.options,\n          delay = _this$options3.delay,\n          repeat = _this$options3.repeat,\n          repeatType = _this$options3.repeatType,\n          repeatDelay = _this$options3.repeatDelay,\n          onUpdate = _this$options3.onUpdate;\n      /**\n       * requestAnimationFrame timestamps can come through as lower than\n       * the startTime as set by performance.now(). Here we prevent this,\n       * though in the future it could be possible to make setting startTime\n       * a pending operation that gets resolved here.\n       */\n\n      if (this.speed > 0) {\n        this.startTime = Math.min(this.startTime, timestamp);\n      } else if (this.speed < 0) {\n        this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);\n      } // Update currentTime\n\n\n      if (sample) {\n        this.currentTime = timestamp;\n      } else if (this.holdTime !== null) {\n        this.currentTime = this.holdTime;\n      } else {\n        // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n        // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n        // example.\n        this.currentTime = Math.round(timestamp - this.startTime) * this.speed;\n      } // Rebase on delay\n\n\n      var timeWithoutDelay = this.currentTime - delay * (this.speed >= 0 ? 1 : -1);\n      var isInDelayPhase = this.speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;\n      this.currentTime = Math.max(timeWithoutDelay, 0); // If this animation has finished, set the current time  to the total duration.\n\n      if (this.state === \"finished\" && this.holdTime === null) {\n        this.currentTime = totalDuration;\n      }\n\n      var elapsed = this.currentTime;\n      var frameGenerator = generator;\n\n      if (repeat) {\n        /**\n         * Get the current progress (0-1) of the animation. If t is >\n         * than duration we'll get values like 2.5 (midway through the\n         * third iteration)\n         */\n        var progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;\n        /**\n         * Get the current iteration (0 indexed). For instance the floor of\n         * 2.5 is 2.\n         */\n\n        var currentIteration = Math.floor(progress);\n        /**\n         * Get the current progress of the iteration by taking the remainder\n         * so 2.5 is 0.5 through iteration 2\n         */\n\n        var iterationProgress = progress % 1.0;\n        /**\n         * If iteration progress is 1 we count that as the end\n         * of the previous iteration.\n         */\n\n        if (!iterationProgress && progress >= 1) {\n          iterationProgress = 1;\n        }\n\n        iterationProgress === 1 && currentIteration--;\n        currentIteration = Math.min(currentIteration, repeat + 1);\n        /**\n         * Reverse progress if we're not running in \"normal\" direction\n         */\n\n        var isOddIteration = Boolean(currentIteration % 2);\n\n        if (isOddIteration) {\n          if (repeatType === \"reverse\") {\n            iterationProgress = 1 - iterationProgress;\n\n            if (repeatDelay) {\n              iterationProgress -= repeatDelay / resolvedDuration;\n            }\n          } else if (repeatType === \"mirror\") {\n            frameGenerator = mirroredGenerator;\n          }\n        }\n\n        elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\n      }\n      /**\n       * If we're in negative time, set state as the initial keyframe.\n       * This prevents delay: x, duration: 0 animations from finishing\n       * instantly.\n       */\n\n\n      var state = isInDelayPhase ? {\n        done: false,\n        value: keyframes[0]\n      } : frameGenerator.next(elapsed);\n\n      if (mapPercentToKeyframes) {\n        state.value = mapPercentToKeyframes(state.value);\n      }\n\n      var done = state.done;\n\n      if (!isInDelayPhase && calculatedDuration !== null) {\n        done = this.speed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;\n      }\n\n      var isAnimationFinished = this.holdTime === null && (this.state === \"finished\" || this.state === \"running\" && done);\n\n      if (isAnimationFinished && finalKeyframe !== undefined) {\n        state.value = getFinalKeyframe(keyframes, this.options, finalKeyframe);\n      }\n\n      if (onUpdate) {\n        onUpdate(state.value);\n      }\n\n      if (isAnimationFinished) {\n        this.finish();\n      }\n\n      return state;\n    }\n  }, {\n    key: \"duration\",\n    get: function get() {\n      var resolved = this.resolved;\n      return resolved ? millisecondsToSeconds(resolved.calculatedDuration) : 0;\n    }\n  }, {\n    key: \"time\",\n    get: function get() {\n      return millisecondsToSeconds(this.currentTime);\n    },\n    set: function set(newTime) {\n      newTime = secondsToMilliseconds(newTime);\n      this.currentTime = newTime;\n\n      if (this.holdTime !== null || this.speed === 0) {\n        this.holdTime = newTime;\n      } else if (this.driver) {\n        this.startTime = this.driver.now() - newTime / this.speed;\n      }\n    }\n  }, {\n    key: \"speed\",\n    get: function get() {\n      return this.playbackSpeed;\n    },\n    set: function set(newSpeed) {\n      var hasChanged = this.playbackSpeed !== newSpeed;\n      this.playbackSpeed = newSpeed;\n\n      if (hasChanged) {\n        this.time = millisecondsToSeconds(this.currentTime);\n      }\n    }\n  }, {\n    key: \"play\",\n    value: function play() {\n      var _this2 = this;\n\n      if (!this.resolver.isScheduled) {\n        this.resolver.resume();\n      }\n\n      if (!this._resolved) {\n        this.pendingPlayState = \"running\";\n        return;\n      }\n\n      if (this.isStopped) return;\n      var _this$options4 = this.options,\n          _this$options4$driver = _this$options4.driver,\n          driver = _this$options4$driver === void 0 ? frameloopDriver : _this$options4$driver,\n          onPlay = _this$options4.onPlay;\n\n      if (!this.driver) {\n        this.driver = driver(function (timestamp) {\n          return _this2.tick(timestamp);\n        });\n      }\n\n      onPlay && onPlay();\n      var now = this.driver.now();\n\n      if (this.holdTime !== null) {\n        this.startTime = now - this.holdTime;\n      } else if (!this.startTime || this.state === \"finished\") {\n        this.startTime = now;\n      }\n\n      if (this.state === \"finished\") {\n        this.updateFinishedPromise();\n      }\n\n      this.cancelTime = this.startTime;\n      this.holdTime = null;\n      /**\n       * Set playState to running only after we've used it in\n       * the previous logic.\n       */\n\n      this.state = \"running\";\n      this.driver.start();\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      var _a;\n\n      if (!this._resolved) {\n        this.pendingPlayState = \"paused\";\n        return;\n      }\n\n      this.state = \"paused\";\n      this.holdTime = (_a = this.currentTime) !== null && _a !== void 0 ? _a : 0;\n    }\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      if (this.state !== \"running\") {\n        this.play();\n      }\n\n      this.pendingPlayState = this.state = \"finished\";\n      this.holdTime = null;\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      this.teardown();\n      this.state = \"finished\";\n      var onComplete = this.options.onComplete;\n      onComplete && onComplete();\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      if (this.cancelTime !== null) {\n        this.tick(this.cancelTime);\n      }\n\n      this.teardown();\n      this.updateFinishedPromise();\n    }\n  }, {\n    key: \"teardown\",\n    value: function teardown() {\n      this.state = \"idle\";\n      this.stopDriver();\n      this.resolveFinishedPromise();\n      this.updateFinishedPromise();\n      this.startTime = this.cancelTime = null;\n      this.resolver.cancel();\n    }\n  }, {\n    key: \"stopDriver\",\n    value: function stopDriver() {\n      if (!this.driver) return;\n      this.driver.stop();\n      this.driver = undefined;\n    }\n  }, {\n    key: \"sample\",\n    value: function sample(time) {\n      this.startTime = 0;\n      return this.tick(time, true);\n    }\n  }]);\n\n  return MainThreadAnimation;\n}(BaseAnimation); // Legacy interface\n\n\nfunction animateValue(options) {\n  return new MainThreadAnimation(options);\n}\n\nexport { MainThreadAnimation, animateValue };","map":null,"metadata":{},"sourceType":"module"}