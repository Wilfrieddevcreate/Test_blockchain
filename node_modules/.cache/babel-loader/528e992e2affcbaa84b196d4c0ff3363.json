{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _defineProperty from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classCallCheck from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _wrapNativeSuper from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";\n\nvar _connectEventErrorsCo, _sendTransactionError;\n\nimport _regeneratorRuntime from \"C:\\\\Users\\\\wilfr\\\\OneDrive\\\\Documents\\\\maxitapbotlatestversionv2\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\";\nimport { CONNECT_EVENT_ERROR_CODES, SEND_TRANSACTION_ERROR_CODES, Base64, SessionCrypto, hexToByteArray } from '@tonconnect/protocol';\nexport { CHAIN, CONNECT_EVENT_ERROR_CODES, CONNECT_ITEM_ERROR_CODES, SEND_TRANSACTION_ERROR_CODES } from '@tonconnect/protocol';\nimport '@tonconnect/isomorphic-eventsource';\nimport '@tonconnect/isomorphic-fetch';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n/**\n * Base class for TonConnect errors. You can check if the error was triggered by the @tonconnect/sdk using `err instanceof TonConnectError`.\n */\n\n\nvar TonConnectError = /*#__PURE__*/function (_Error) {\n  _inherits(TonConnectError, _Error);\n\n  var _super = _createSuper(TonConnectError);\n\n  function TonConnectError(message, options) {\n    var _this;\n\n    _classCallCheck(this, TonConnectError);\n\n    _this = _super.call(this, message, options);\n    _this.message = \"\".concat(TonConnectError.prefix, \" \").concat(_this.constructor.name).concat(_this.info ? ': ' + _this.info : '').concat(message ? '\\n' + message : '');\n    Object.setPrototypeOf(_assertThisInitialized(_this), TonConnectError.prototype);\n    return _this;\n  }\n\n  _createClass(TonConnectError, [{\n    key: \"info\",\n    get: function get() {\n      return '';\n    }\n  }]);\n\n  return TonConnectError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nTonConnectError.prefix = '[TON_CONNECT_SDK_ERROR]';\n/**\n * Thrown when passed DappMetadata is in incorrect format.\n */\n\nvar DappMetadataError = /*#__PURE__*/function (_TonConnectError) {\n  _inherits(DappMetadataError, _TonConnectError);\n\n  var _super2 = _createSuper(DappMetadataError);\n\n  function DappMetadataError() {\n    var _this2;\n\n    _classCallCheck(this, DappMetadataError);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this2 = _super2.call.apply(_super2, [this].concat(args));\n    Object.setPrototypeOf(_assertThisInitialized(_this2), DappMetadataError.prototype);\n    return _this2;\n  }\n\n  _createClass(DappMetadataError, [{\n    key: \"info\",\n    get: function get() {\n      return 'Passed DappMetadata is in incorrect format.';\n    }\n  }]);\n\n  return DappMetadataError;\n}(TonConnectError);\n/**\n * Thrown when passed manifest contains errors.\n */\n\n\nvar ManifestContentErrorError = /*#__PURE__*/function (_TonConnectError2) {\n  _inherits(ManifestContentErrorError, _TonConnectError2);\n\n  var _super3 = _createSuper(ManifestContentErrorError);\n\n  function ManifestContentErrorError() {\n    var _this3;\n\n    _classCallCheck(this, ManifestContentErrorError);\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    _this3 = _super3.call.apply(_super3, [this].concat(args));\n    Object.setPrototypeOf(_assertThisInitialized(_this3), ManifestContentErrorError.prototype);\n    return _this3;\n  }\n\n  _createClass(ManifestContentErrorError, [{\n    key: \"info\",\n    get: function get() {\n      return 'Passed `tonconnect-manifest.json` contains errors. Check format of your manifest. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest';\n    }\n  }]);\n\n  return ManifestContentErrorError;\n}(TonConnectError);\n/**\n * Thrown when wallet can't get manifest by passed manifestUrl.\n */\n\n\nvar ManifestNotFoundError = /*#__PURE__*/function (_TonConnectError3) {\n  _inherits(ManifestNotFoundError, _TonConnectError3);\n\n  var _super4 = _createSuper(ManifestNotFoundError);\n\n  function ManifestNotFoundError() {\n    var _this4;\n\n    _classCallCheck(this, ManifestNotFoundError);\n\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    _this4 = _super4.call.apply(_super4, [this].concat(args));\n    Object.setPrototypeOf(_assertThisInitialized(_this4), ManifestNotFoundError.prototype);\n    return _this4;\n  }\n\n  _createClass(ManifestNotFoundError, [{\n    key: \"info\",\n    get: function get() {\n      return 'Manifest not found. Make sure you added `tonconnect-manifest.json` to the root of your app or passed correct manifestUrl. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest';\n    }\n  }]);\n\n  return ManifestNotFoundError;\n}(TonConnectError);\n/**\n * Thrown when wallet connection called but wallet already connected. To avoid the error, disconnect the wallet before doing a new connection.\n */\n\n\nvar WalletAlreadyConnectedError = /*#__PURE__*/function (_TonConnectError4) {\n  _inherits(WalletAlreadyConnectedError, _TonConnectError4);\n\n  var _super5 = _createSuper(WalletAlreadyConnectedError);\n\n  function WalletAlreadyConnectedError() {\n    var _this5;\n\n    _classCallCheck(this, WalletAlreadyConnectedError);\n\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    _this5 = _super5.call.apply(_super5, [this].concat(args));\n    Object.setPrototypeOf(_assertThisInitialized(_this5), WalletAlreadyConnectedError.prototype);\n    return _this5;\n  }\n\n  _createClass(WalletAlreadyConnectedError, [{\n    key: \"info\",\n    get: function get() {\n      return 'Wallet connection called but wallet already connected. To avoid the error, disconnect the wallet before doing a new connection.';\n    }\n  }]);\n\n  return WalletAlreadyConnectedError;\n}(TonConnectError);\n/**\n * Thrown when send transaction or other protocol methods called while wallet is not connected.\n */\n\n\nvar WalletNotConnectedError = /*#__PURE__*/function (_TonConnectError5) {\n  _inherits(WalletNotConnectedError, _TonConnectError5);\n\n  var _super6 = _createSuper(WalletNotConnectedError);\n\n  function WalletNotConnectedError() {\n    var _this6;\n\n    _classCallCheck(this, WalletNotConnectedError);\n\n    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      args[_key5] = arguments[_key5];\n    }\n\n    _this6 = _super6.call.apply(_super6, [this].concat(args));\n    Object.setPrototypeOf(_assertThisInitialized(_this6), WalletNotConnectedError.prototype);\n    return _this6;\n  }\n\n  _createClass(WalletNotConnectedError, [{\n    key: \"info\",\n    get: function get() {\n      return 'Send transaction or other protocol methods called while wallet is not connected.';\n    }\n  }]);\n\n  return WalletNotConnectedError;\n}(TonConnectError);\n\nfunction isWalletConnectionSourceJS(value) {\n  return 'jsBridgeKey' in value;\n}\n/**\n * Thrown when user rejects the action in the wallet.\n */\n\n\nvar UserRejectsError = /*#__PURE__*/function (_TonConnectError6) {\n  _inherits(UserRejectsError, _TonConnectError6);\n\n  var _super7 = _createSuper(UserRejectsError);\n\n  function UserRejectsError() {\n    var _this7;\n\n    _classCallCheck(this, UserRejectsError);\n\n    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n\n    _this7 = _super7.call.apply(_super7, [this].concat(args));\n    Object.setPrototypeOf(_assertThisInitialized(_this7), UserRejectsError.prototype);\n    return _this7;\n  }\n\n  _createClass(UserRejectsError, [{\n    key: \"info\",\n    get: function get() {\n      return 'User rejects the action in the wallet.';\n    }\n  }]);\n\n  return UserRejectsError;\n}(TonConnectError);\n/**\n * Thrown when request to the wallet contains errors.\n */\n\n\nvar BadRequestError = /*#__PURE__*/function (_TonConnectError7) {\n  _inherits(BadRequestError, _TonConnectError7);\n\n  var _super8 = _createSuper(BadRequestError);\n\n  function BadRequestError() {\n    var _this8;\n\n    _classCallCheck(this, BadRequestError);\n\n    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      args[_key7] = arguments[_key7];\n    }\n\n    _this8 = _super8.call.apply(_super8, [this].concat(args));\n    Object.setPrototypeOf(_assertThisInitialized(_this8), BadRequestError.prototype);\n    return _this8;\n  }\n\n  _createClass(BadRequestError, [{\n    key: \"info\",\n    get: function get() {\n      return 'Request to the wallet contains errors.';\n    }\n  }]);\n\n  return BadRequestError;\n}(TonConnectError);\n/**\n * Thrown when app tries to send rpc request to the injected wallet while not connected.\n */\n\n\nvar UnknownAppError = /*#__PURE__*/function (_TonConnectError8) {\n  _inherits(UnknownAppError, _TonConnectError8);\n\n  var _super9 = _createSuper(UnknownAppError);\n\n  function UnknownAppError() {\n    var _this9;\n\n    _classCallCheck(this, UnknownAppError);\n\n    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      args[_key8] = arguments[_key8];\n    }\n\n    _this9 = _super9.call.apply(_super9, [this].concat(args));\n    Object.setPrototypeOf(_assertThisInitialized(_this9), UnknownAppError.prototype);\n    return _this9;\n  }\n\n  _createClass(UnknownAppError, [{\n    key: \"info\",\n    get: function get() {\n      return 'App tries to send rpc request to the injected wallet while not connected.';\n    }\n  }]);\n\n  return UnknownAppError;\n}(TonConnectError);\n/**\n * Thrown when there is an attempt to connect to the injected wallet while it is not exists in the webpage.\n */\n\n\nvar WalletNotInjectedError = /*#__PURE__*/function (_TonConnectError9) {\n  _inherits(WalletNotInjectedError, _TonConnectError9);\n\n  var _super10 = _createSuper(WalletNotInjectedError);\n\n  function WalletNotInjectedError() {\n    var _this10;\n\n    _classCallCheck(this, WalletNotInjectedError);\n\n    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n      args[_key9] = arguments[_key9];\n    }\n\n    _this10 = _super10.call.apply(_super10, [this].concat(args));\n    Object.setPrototypeOf(_assertThisInitialized(_this10), WalletNotInjectedError.prototype);\n    return _this10;\n  }\n\n  _createClass(WalletNotInjectedError, [{\n    key: \"info\",\n    get: function get() {\n      return 'There is an attempt to connect to the injected wallet while it is not exists in the webpage.';\n    }\n  }]);\n\n  return WalletNotInjectedError;\n}(TonConnectError);\n/**\n * Thrown when `Storage` was not specified in the `DappMetadata` and default `localStorage` was not detected in the Node.js environment.\n */\n\n\nvar LocalstorageNotFoundError = /*#__PURE__*/function (_TonConnectError10) {\n  _inherits(LocalstorageNotFoundError, _TonConnectError10);\n\n  var _super11 = _createSuper(LocalstorageNotFoundError);\n\n  function LocalstorageNotFoundError() {\n    var _this11;\n\n    _classCallCheck(this, LocalstorageNotFoundError);\n\n    for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n      args[_key10] = arguments[_key10];\n    }\n\n    _this11 = _super11.call.apply(_super11, [this].concat(args));\n    Object.setPrototypeOf(_assertThisInitialized(_this11), LocalstorageNotFoundError.prototype);\n    return _this11;\n  }\n\n  _createClass(LocalstorageNotFoundError, [{\n    key: \"info\",\n    get: function get() {\n      return 'Storage was not specified in the `DappMetadata` and default `localStorage` was not detected in the environment.';\n    }\n  }]);\n\n  return LocalstorageNotFoundError;\n}(TonConnectError);\n/**\n * Thrown when an error occurred while fetching the wallets list.\n */\n\n\nvar FetchWalletsError = /*#__PURE__*/function (_TonConnectError11) {\n  _inherits(FetchWalletsError, _TonConnectError11);\n\n  var _super12 = _createSuper(FetchWalletsError);\n\n  function FetchWalletsError() {\n    var _this12;\n\n    _classCallCheck(this, FetchWalletsError);\n\n    for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n      args[_key11] = arguments[_key11];\n    }\n\n    _this12 = _super12.call.apply(_super12, [this].concat(args));\n    Object.setPrototypeOf(_assertThisInitialized(_this12), FetchWalletsError.prototype);\n    return _this12;\n  }\n\n  _createClass(FetchWalletsError, [{\n    key: \"info\",\n    get: function get() {\n      return 'An error occurred while fetching the wallets list.';\n    }\n  }]);\n\n  return FetchWalletsError;\n}(TonConnectError);\n/**\n * Thrown when passed address is in incorrect format.\n */\n\n\nvar WrongAddressError = /*#__PURE__*/function (_TonConnectError12) {\n  _inherits(WrongAddressError, _TonConnectError12);\n\n  var _super13 = _createSuper(WrongAddressError);\n\n  function WrongAddressError() {\n    var _this13;\n\n    _classCallCheck(this, WrongAddressError);\n\n    for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n      args[_key12] = arguments[_key12];\n    }\n\n    _this13 = _super13.call.apply(_super13, [this].concat(args));\n    Object.setPrototypeOf(_assertThisInitialized(_this13), WrongAddressError.prototype);\n    return _this13;\n  }\n\n  _createClass(WrongAddressError, [{\n    key: \"info\",\n    get: function get() {\n      return 'Passed address is in incorrect format.';\n    }\n  }]);\n\n  return WrongAddressError;\n}(TonConnectError);\n/**\n * Thrown when passed hex is in incorrect format.\n */\n\n\nvar ParseHexError = /*#__PURE__*/function (_TonConnectError13) {\n  _inherits(ParseHexError, _TonConnectError13);\n\n  var _super14 = _createSuper(ParseHexError);\n\n  function ParseHexError() {\n    var _this14;\n\n    _classCallCheck(this, ParseHexError);\n\n    for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n      args[_key13] = arguments[_key13];\n    }\n\n    _this14 = _super14.call.apply(_super14, [this].concat(args));\n    Object.setPrototypeOf(_assertThisInitialized(_this14), ParseHexError.prototype);\n    return _this14;\n  }\n\n  _createClass(ParseHexError, [{\n    key: \"info\",\n    get: function get() {\n      return 'Passed hex is in incorrect format.';\n    }\n  }]);\n\n  return ParseHexError;\n}(TonConnectError);\n/**\n * Unhanded unknown error.\n */\n\n\nvar UnknownError = /*#__PURE__*/function (_TonConnectError14) {\n  _inherits(UnknownError, _TonConnectError14);\n\n  var _super15 = _createSuper(UnknownError);\n\n  function UnknownError() {\n    var _this15;\n\n    _classCallCheck(this, UnknownError);\n\n    for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n      args[_key14] = arguments[_key14];\n    }\n\n    _this15 = _super15.call.apply(_super15, [this].concat(args));\n    Object.setPrototypeOf(_assertThisInitialized(_this15), UnknownError.prototype);\n    return _this15;\n  }\n\n  return _createClass(UnknownError);\n}(TonConnectError);\n\nvar connectEventErrorsCodes = (_connectEventErrorsCo = {}, _defineProperty(_connectEventErrorsCo, CONNECT_EVENT_ERROR_CODES.UNKNOWN_ERROR, UnknownError), _defineProperty(_connectEventErrorsCo, CONNECT_EVENT_ERROR_CODES.USER_REJECTS_ERROR, UserRejectsError), _defineProperty(_connectEventErrorsCo, CONNECT_EVENT_ERROR_CODES.BAD_REQUEST_ERROR, BadRequestError), _defineProperty(_connectEventErrorsCo, CONNECT_EVENT_ERROR_CODES.UNKNOWN_APP_ERROR, UnknownAppError), _defineProperty(_connectEventErrorsCo, CONNECT_EVENT_ERROR_CODES.MANIFEST_NOT_FOUND_ERROR, ManifestNotFoundError), _defineProperty(_connectEventErrorsCo, CONNECT_EVENT_ERROR_CODES.MANIFEST_CONTENT_ERROR, ManifestContentErrorError), _connectEventErrorsCo);\n\nvar ConnectErrorsParser = /*#__PURE__*/function () {\n  function ConnectErrorsParser() {\n    _classCallCheck(this, ConnectErrorsParser);\n  }\n\n  _createClass(ConnectErrorsParser, [{\n    key: \"parseError\",\n    value: function parseError(error) {\n      var ErrorConstructor = UnknownError;\n\n      if (error.code in connectEventErrorsCodes) {\n        ErrorConstructor = connectEventErrorsCodes[error.code] || UnknownError;\n      }\n\n      return new ErrorConstructor(error.message);\n    }\n  }]);\n\n  return ConnectErrorsParser;\n}();\n\nvar connectErrorsParser = new ConnectErrorsParser();\n\nvar RpcParser = /*#__PURE__*/function () {\n  function RpcParser() {\n    _classCallCheck(this, RpcParser);\n  }\n\n  _createClass(RpcParser, [{\n    key: \"isError\",\n    value: function isError(response) {\n      return 'error' in response;\n    }\n  }]);\n\n  return RpcParser;\n}();\n\nvar sendTransactionErrors = (_sendTransactionError = {}, _defineProperty(_sendTransactionError, SEND_TRANSACTION_ERROR_CODES.UNKNOWN_ERROR, UnknownError), _defineProperty(_sendTransactionError, SEND_TRANSACTION_ERROR_CODES.USER_REJECTS_ERROR, UserRejectsError), _defineProperty(_sendTransactionError, SEND_TRANSACTION_ERROR_CODES.BAD_REQUEST_ERROR, BadRequestError), _defineProperty(_sendTransactionError, SEND_TRANSACTION_ERROR_CODES.UNKNOWN_APP_ERROR, UnknownAppError), _sendTransactionError);\n\nvar SendTransactionParser = /*#__PURE__*/function (_RpcParser) {\n  _inherits(SendTransactionParser, _RpcParser);\n\n  var _super16 = _createSuper(SendTransactionParser);\n\n  function SendTransactionParser() {\n    _classCallCheck(this, SendTransactionParser);\n\n    return _super16.apply(this, arguments);\n  }\n\n  _createClass(SendTransactionParser, [{\n    key: \"convertToRpcRequest\",\n    value: function convertToRpcRequest(request) {\n      return {\n        method: 'sendTransaction',\n        params: [JSON.stringify(request)]\n      };\n    }\n  }, {\n    key: \"parseAndThrowError\",\n    value: function parseAndThrowError(response) {\n      var ErrorConstructor = UnknownError;\n\n      if (response.error.code in sendTransactionErrors) {\n        ErrorConstructor = sendTransactionErrors[response.error.code] || UnknownError;\n      }\n\n      throw new ErrorConstructor(response.error.message);\n    }\n  }, {\n    key: \"convertFromRpcResponse\",\n    value: function convertFromRpcResponse(rpcResponse) {\n      return {\n        boc: rpcResponse.result\n      };\n    }\n  }]);\n\n  return SendTransactionParser;\n}(RpcParser);\n\nvar sendTransactionParser = new SendTransactionParser();\n\nvar HttpBridgeGatewayStorage = /*#__PURE__*/function () {\n  function HttpBridgeGatewayStorage(storage, bridgeUrl) {\n    _classCallCheck(this, HttpBridgeGatewayStorage);\n\n    this.storage = storage;\n    this.storeKey = 'ton-connect-storage_http-bridge-gateway::' + bridgeUrl;\n  }\n\n  _createClass(HttpBridgeGatewayStorage, [{\n    key: \"storeLastEventId\",\n    value: function storeLastEventId(lastEventId) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", this.storage.setItem(this.storeKey, lastEventId));\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n  }, {\n    key: \"removeLastEventId\",\n    value: function removeLastEventId() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", this.storage.removeItem(this.storeKey));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n  }, {\n    key: \"getLastEventId\",\n    value: function getLastEventId() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var stored;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.storage.getItem(this.storeKey);\n\n              case 2:\n                stored = _context3.sent;\n\n                if (stored) {\n                  _context3.next = 5;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", null);\n\n              case 5:\n                return _context3.abrupt(\"return\", stored);\n\n              case 6:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n  }]);\n\n  return HttpBridgeGatewayStorage;\n}();\n\nfunction removeUrlLastSlash(url) {\n  if (url.slice(-1) === '/') {\n    return url.slice(0, -1);\n  }\n\n  return url;\n}\n\nfunction addPathToUrl(url, path) {\n  return removeUrlLastSlash(url) + '/' + path;\n}\n\nfunction isTelegramUrl(link) {\n  if (!link) {\n    return false;\n  }\n\n  var url = new URL(link);\n  return url.protocol === 'tg:' || url.hostname === 't.me';\n}\n\nfunction encodeTelegramUrlParameters(parameters) {\n  return parameters.replaceAll('.', '%2E').replaceAll('-', '%2D').replaceAll('_', '%5F').replaceAll('&', '-').replaceAll('=', '__').replaceAll('%', '--');\n}\n/**\n * Delays the execution of code for a specified number of milliseconds.\n * @param {number} timeout - The number of milliseconds to delay the execution.\n * @param {DelayOptions} [options] - Optional configuration options for the delay.\n * @return {Promise<void>} - A promise that resolves after the specified delay, or rejects if the delay is aborted.\n */\n\n\nfunction delay(timeout, options) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            return _context4.abrupt(\"return\", new Promise(function (resolve, reject) {\n              var _a, _b;\n\n              if ((_a = options === null || options === void 0 ? void 0 : options.signal) === null || _a === void 0 ? void 0 : _a.aborted) {\n                reject(new TonConnectError('Delay aborted'));\n                return;\n              }\n\n              var timeoutId = setTimeout(function () {\n                return resolve();\n              }, timeout);\n              (_b = options === null || options === void 0 ? void 0 : options.signal) === null || _b === void 0 ? void 0 : _b.addEventListener('abort', function () {\n                clearTimeout(timeoutId);\n                reject(new TonConnectError('Delay aborted'));\n              });\n            }));\n\n          case 1:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n}\n/**\n * Creates an AbortController instance with an optional AbortSignal.\n *\n * @param {AbortSignal} [signal] - An optional AbortSignal to use for aborting the controller.\n * @returns {AbortController} - An instance of AbortController.\n */\n\n\nfunction createAbortController(signal) {\n  var abortController = new AbortController();\n\n  if (signal === null || signal === void 0 ? void 0 : signal.aborted) {\n    abortController.abort();\n  } else {\n    signal === null || signal === void 0 ? void 0 : signal.addEventListener('abort', function () {\n      return abortController.abort();\n    }, {\n      once: true\n    });\n  }\n\n  return abortController;\n}\n/**\n * Function to call ton api until we get response.\n * Because ton network is pretty unstable we need to make sure response is final.\n * @param {T} fn - function to call\n * @param {CallForSuccessOptions} [options] - optional configuration options\n */\n\n\nfunction callForSuccess(fn, options) {\n  var _a, _b;\n\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n    var attempts, delayMs, abortController, i, lastError;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            attempts = (_a = options === null || options === void 0 ? void 0 : options.attempts) !== null && _a !== void 0 ? _a : 10;\n            delayMs = (_b = options === null || options === void 0 ? void 0 : options.delayMs) !== null && _b !== void 0 ? _b : 200;\n            abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n\n            if (!(typeof fn !== 'function')) {\n              _context5.next = 5;\n              break;\n            }\n\n            throw new TonConnectError(\"Expected a function, got \".concat(typeof fn));\n\n          case 5:\n            i = 0;\n\n          case 6:\n            if (!(i < attempts)) {\n              _context5.next = 24;\n              break;\n            }\n\n            if (!abortController.signal.aborted) {\n              _context5.next = 9;\n              break;\n            }\n\n            throw new TonConnectError(\"Aborted after attempts \".concat(i));\n\n          case 9:\n            _context5.prev = 9;\n            _context5.next = 12;\n            return fn({\n              signal: abortController.signal\n            });\n\n          case 12:\n            return _context5.abrupt(\"return\", _context5.sent);\n\n          case 15:\n            _context5.prev = 15;\n            _context5.t0 = _context5[\"catch\"](9);\n            lastError = _context5.t0;\n            i++;\n\n            if (!(i < attempts)) {\n              _context5.next = 22;\n              break;\n            }\n\n            _context5.next = 22;\n            return delay(delayMs);\n\n          case 22:\n            _context5.next = 6;\n            break;\n\n          case 24:\n            throw lastError;\n\n          case 25:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5, null, [[9, 15]]);\n  }));\n}\n\nfunction logDebug() {\n  {\n    try {\n      var _console;\n\n      for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n        args[_key15] = arguments[_key15];\n      }\n\n      (_console = console).debug.apply(_console, ['[TON_CONNECT_SDK]'].concat(args));\n    } catch (_a) {}\n  }\n}\n\nfunction logError() {\n  {\n    try {\n      var _console2;\n\n      for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n        args[_key16] = arguments[_key16];\n      }\n\n      (_console2 = console).error.apply(_console2, ['[TON_CONNECT_SDK]'].concat(args));\n    } catch (_a) {}\n  }\n}\n\nfunction logWarning() {\n  {\n    try {\n      var _console3;\n\n      for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {\n        args[_key17] = arguments[_key17];\n      }\n\n      (_console3 = console).warn.apply(_console3, ['[TON_CONNECT_SDK]'].concat(args));\n    } catch (_a) {}\n  }\n}\n/**\n * Create a resource.\n *\n * @template T - The type of the resource.\n * @template Args - The type of the arguments for creating the resource.\n *\n * @param {(...args: Args) => Promise<T>} createFn - A function that creates the resource.\n * @param {(resource: T) => Promise<void>} [disposeFn] - An optional function that disposes the resource.\n */\n\n\nfunction createResource(createFn, disposeFn) {\n  var _this16 = this;\n\n  var currentResource = null;\n  var currentArgs = null;\n  var currentPromise = null;\n  var currentSignal = null;\n  var abortController = null; // create a new resource\n\n  var create = function create(signal) {\n    for (var _len18 = arguments.length, args = new Array(_len18 > 1 ? _len18 - 1 : 0), _key18 = 1; _key18 < _len18; _key18++) {\n      args[_key18 - 1] = arguments[_key18];\n    }\n\n    return __awaiter(_this16, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n      var promise, resource;\n      return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              currentSignal = signal !== null && signal !== void 0 ? signal : null;\n              abortController === null || abortController === void 0 ? void 0 : abortController.abort();\n              abortController = createAbortController(signal);\n\n              if (!abortController.signal.aborted) {\n                _context6.next = 5;\n                break;\n              }\n\n              throw new TonConnectError('Resource creation was aborted');\n\n            case 5:\n              currentArgs = args !== null && args !== void 0 ? args : null;\n              promise = createFn.apply(void 0, [abortController.signal].concat(args));\n              currentPromise = promise;\n              _context6.next = 10;\n              return promise;\n\n            case 10:\n              resource = _context6.sent;\n\n              if (!(currentPromise !== promise && resource !== currentResource)) {\n                _context6.next = 15;\n                break;\n              }\n\n              _context6.next = 14;\n              return disposeFn(resource);\n\n            case 14:\n              throw new TonConnectError('Resource creation was aborted by a new resource creation');\n\n            case 15:\n              currentResource = resource;\n              return _context6.abrupt(\"return\", currentResource);\n\n            case 17:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, _callee6);\n    }));\n  }; // get the current resource\n\n\n  var current = function current() {\n    return currentResource !== null && currentResource !== void 0 ? currentResource : null;\n  }; // dispose the current resource\n\n\n  var dispose = function dispose() {\n    return __awaiter(_this16, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n      var resource, promise;\n      return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              _context7.prev = 0;\n              resource = currentResource;\n              currentResource = null;\n              promise = currentPromise;\n              currentPromise = null;\n\n              try {\n                abortController === null || abortController === void 0 ? void 0 : abortController.abort();\n              } catch (e) {}\n\n              _context7.t0 = Promise;\n              _context7.t1 = resource ? disposeFn(resource) : Promise.resolve();\n\n              if (!promise) {\n                _context7.next = 16;\n                break;\n              }\n\n              _context7.t3 = disposeFn;\n              _context7.next = 12;\n              return promise;\n\n            case 12:\n              _context7.t4 = _context7.sent;\n              _context7.t2 = (0, _context7.t3)(_context7.t4);\n              _context7.next = 17;\n              break;\n\n            case 16:\n              _context7.t2 = Promise.resolve();\n\n            case 17:\n              _context7.t5 = _context7.t2;\n              _context7.t6 = [_context7.t1, _context7.t5];\n              _context7.next = 21;\n              return _context7.t0.allSettled.call(_context7.t0, _context7.t6);\n\n            case 21:\n              _context7.next = 25;\n              break;\n\n            case 23:\n              _context7.prev = 23;\n              _context7.t7 = _context7[\"catch\"](0);\n\n            case 25:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, _callee7, null, [[0, 23]]);\n    }));\n  }; // recreate the current resource\n\n\n  var recreate = function recreate(delayMs) {\n    return __awaiter(_this16, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n      var resource, promise, args, signal;\n      return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              resource = currentResource;\n              promise = currentPromise;\n              args = currentArgs;\n              signal = currentSignal;\n              _context8.next = 6;\n              return delay(delayMs);\n\n            case 6:\n              if (!(resource === currentResource && promise === currentPromise && args === currentArgs && signal === currentSignal)) {\n                _context8.next = 10;\n                break;\n              }\n\n              _context8.next = 9;\n              return create.apply(void 0, [currentSignal].concat(_toConsumableArray(args !== null && args !== void 0 ? args : [])));\n\n            case 9:\n              return _context8.abrupt(\"return\", _context8.sent);\n\n            case 10:\n              throw new TonConnectError('Resource recreation was aborted by a new resource creation');\n\n            case 11:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n      }, _callee8);\n    }));\n  };\n\n  return {\n    create: create,\n    current: current,\n    dispose: dispose,\n    recreate: recreate\n  };\n}\n/**\n * Executes a function and provides deferred behavior, allowing for a timeout and abort functionality.\n *\n * @param {Deferrable<T>} fn - The function to execute. It should return a promise that resolves with the desired result.\n * @param {DeferOptions} options - Optional configuration options for the defer behavior.\n * @returns {Promise<T>} - A promise that resolves with the result of the executed function, or rejects with an error if it times out or is aborted.\n */\n\n\nfunction timeout(fn, options) {\n  var timeout = options === null || options === void 0 ? void 0 : options.timeout;\n  var signal = options === null || options === void 0 ? void 0 : options.signal;\n  var abortController = createAbortController(signal);\n  return new Promise(function (resolve, reject) {\n    if (abortController.signal.aborted) {\n      reject(new TonConnectError('Operation aborted'));\n      return;\n    }\n\n    var timeoutId;\n\n    if (typeof timeout !== 'undefined') {\n      timeoutId = setTimeout(function () {\n        abortController.abort();\n        reject(new TonConnectError(\"Timeout after \".concat(timeout, \"ms\")));\n      }, timeout);\n    }\n\n    abortController.signal.addEventListener('abort', function () {\n      clearTimeout(timeoutId);\n      reject(new TonConnectError('Operation aborted'));\n    }, {\n      once: true\n    });\n    var deferOptions = {\n      timeout: timeout,\n      abort: abortController.signal\n    };\n    fn(resolve, reject, deferOptions).finally(function () {\n      return clearTimeout(timeoutId);\n    });\n  });\n}\n\nvar BridgeGateway = /*#__PURE__*/function () {\n  function BridgeGateway(storage, bridgeUrl, sessionId, listener, errorsListener) {\n    var _this17 = this;\n\n    _classCallCheck(this, BridgeGateway);\n\n    this.bridgeUrl = bridgeUrl;\n    this.sessionId = sessionId;\n    this.listener = listener;\n    this.errorsListener = errorsListener;\n    this.ssePath = 'events';\n    this.postPath = 'message';\n    this.heartbeatMessage = 'heartbeat';\n    this.defaultTtl = 300;\n    this.defaultReconnectDelay = 5000;\n    this.eventSource = createResource(function (signal, openingDeadlineMS) {\n      return __awaiter(_this17, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        var eventSourceConfig;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                eventSourceConfig = {\n                  bridgeUrl: this.bridgeUrl,\n                  ssePath: this.ssePath,\n                  sessionId: this.sessionId,\n                  bridgeGatewayStorage: this.bridgeGatewayStorage,\n                  errorHandler: this.errorsHandler.bind(this),\n                  messageHandler: this.messagesHandler.bind(this),\n                  signal: signal,\n                  openingDeadlineMS: openingDeadlineMS\n                };\n                _context9.next = 3;\n                return createEventSource(eventSourceConfig);\n\n              case 3:\n                return _context9.abrupt(\"return\", _context9.sent);\n\n              case 4:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n    }, function (resource) {\n      return __awaiter(_this17, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                resource.close();\n\n              case 1:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10);\n      }));\n    });\n    this.bridgeGatewayStorage = new HttpBridgeGatewayStorage(storage, bridgeUrl);\n  }\n\n  _createClass(BridgeGateway, [{\n    key: \"isReady\",\n    get: function get() {\n      var eventSource = this.eventSource.current();\n      return (eventSource === null || eventSource === void 0 ? void 0 : eventSource.readyState) === EventSource.OPEN;\n    }\n  }, {\n    key: \"isClosed\",\n    get: function get() {\n      var eventSource = this.eventSource.current();\n      return (eventSource === null || eventSource === void 0 ? void 0 : eventSource.readyState) !== EventSource.OPEN;\n    }\n  }, {\n    key: \"isConnecting\",\n    get: function get() {\n      var eventSource = this.eventSource.current();\n      return (eventSource === null || eventSource === void 0 ? void 0 : eventSource.readyState) === EventSource.CONNECTING;\n    }\n  }, {\n    key: \"registerSession\",\n    value: function registerSession(options) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee11() {\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _context11.next = 2;\n                return this.eventSource.create(options === null || options === void 0 ? void 0 : options.signal, options === null || options === void 0 ? void 0 : options.openingDeadlineMS);\n\n              case 2:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n    }\n  }, {\n    key: \"send\",\n    value: function send(message, receiver, topic, ttlOrOptions) {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee13() {\n        var _this18 = this;\n\n        var options, url, body;\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                // TODO: remove deprecated method\n                options = {};\n\n                if (typeof ttlOrOptions === 'number') {\n                  options.ttl = ttlOrOptions;\n                } else {\n                  options.ttl = ttlOrOptions === null || ttlOrOptions === void 0 ? void 0 : ttlOrOptions.ttl;\n                  options.signal = ttlOrOptions === null || ttlOrOptions === void 0 ? void 0 : ttlOrOptions.signal;\n                  options.attempts = ttlOrOptions === null || ttlOrOptions === void 0 ? void 0 : ttlOrOptions.attempts;\n                }\n\n                url = new URL(addPathToUrl(this.bridgeUrl, this.postPath));\n                url.searchParams.append('client_id', this.sessionId);\n                url.searchParams.append('to', receiver);\n                url.searchParams.append('ttl', ((options === null || options === void 0 ? void 0 : options.ttl) || this.defaultTtl).toString());\n                url.searchParams.append('topic', topic);\n                body = Base64.encode(message);\n                _context13.next = 10;\n                return callForSuccess(function (options) {\n                  return __awaiter(_this18, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee12() {\n                    var response;\n                    return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n                      while (1) {\n                        switch (_context12.prev = _context12.next) {\n                          case 0:\n                            _context12.next = 2;\n                            return this.post(url, body, options.signal);\n\n                          case 2:\n                            response = _context12.sent;\n\n                            if (response.ok) {\n                              _context12.next = 5;\n                              break;\n                            }\n\n                            throw new TonConnectError(\"Bridge send failed, status \".concat(response.status));\n\n                          case 5:\n                          case \"end\":\n                            return _context12.stop();\n                        }\n                      }\n                    }, _callee12, this);\n                  }));\n                }, {\n                  attempts: (_a = options === null || options === void 0 ? void 0 : options.attempts) !== null && _a !== void 0 ? _a : Number.MAX_SAFE_INTEGER,\n                  delayMs: 5000,\n                  signal: options === null || options === void 0 ? void 0 : options.signal\n                });\n\n              case 10:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      this.eventSource.dispose().catch(function (e) {\n        return logError(\"Bridge pause failed, \".concat(e));\n      });\n    }\n  }, {\n    key: \"unPause\",\n    value: function unPause() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee14() {\n        var RECREATE_WITHOUT_DELAY;\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                RECREATE_WITHOUT_DELAY = 0;\n                _context14.next = 3;\n                return this.eventSource.recreate(RECREATE_WITHOUT_DELAY);\n\n              case 3:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee15() {\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                _context15.next = 2;\n                return this.eventSource.dispose().catch(function (e) {\n                  return logError(\"Bridge close failed, \".concat(e));\n                });\n\n              case 2:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n    }\n  }, {\n    key: \"setListener\",\n    value: function setListener(listener) {\n      this.listener = listener;\n    }\n  }, {\n    key: \"setErrorsListener\",\n    value: function setErrorsListener(errorsListener) {\n      this.errorsListener = errorsListener;\n    }\n  }, {\n    key: \"post\",\n    value: function post(url, body, signal) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee16() {\n        var response;\n        return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                _context16.next = 2;\n                return fetch(url, {\n                  method: 'post',\n                  body: body,\n                  signal: signal\n                });\n\n              case 2:\n                response = _context16.sent;\n\n                if (response.ok) {\n                  _context16.next = 5;\n                  break;\n                }\n\n                throw new TonConnectError(\"Bridge send failed, status \".concat(response.status));\n\n              case 5:\n                return _context16.abrupt(\"return\", response);\n\n              case 6:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16);\n      }));\n    }\n  }, {\n    key: \"errorsHandler\",\n    value: function errorsHandler(eventSource, e) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee17() {\n        return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                if (!this.isConnecting) {\n                  _context17.next = 3;\n                  break;\n                }\n\n                logError('Bridge error', JSON.stringify(e));\n                return _context17.abrupt(\"return\");\n\n              case 3:\n                if (!this.isReady) {\n                  _context17.next = 6;\n                  break;\n                }\n\n                try {\n                  this.errorsListener(e);\n                } catch (e) {}\n\n                return _context17.abrupt(\"return\");\n\n              case 6:\n                if (!this.isClosed) {\n                  _context17.next = 12;\n                  break;\n                }\n\n                eventSource.close();\n                logDebug(\"Bridge reconnecting, \".concat(this.defaultReconnectDelay, \"ms delay\"));\n                _context17.next = 11;\n                return this.eventSource.recreate(this.defaultReconnectDelay);\n\n              case 11:\n                return _context17.abrupt(\"return\", _context17.sent);\n\n              case 12:\n                throw new TonConnectError('Bridge error, unknown state');\n\n              case 13:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n    }\n  }, {\n    key: \"messagesHandler\",\n    value: function messagesHandler(e) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee18() {\n        var bridgeIncomingMessage;\n        return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                if (!(e.data === this.heartbeatMessage)) {\n                  _context18.next = 2;\n                  break;\n                }\n\n                return _context18.abrupt(\"return\");\n\n              case 2:\n                _context18.next = 4;\n                return this.bridgeGatewayStorage.storeLastEventId(e.lastEventId);\n\n              case 4:\n                if (!this.isClosed) {\n                  _context18.next = 6;\n                  break;\n                }\n\n                return _context18.abrupt(\"return\");\n\n              case 6:\n                _context18.prev = 6;\n                bridgeIncomingMessage = JSON.parse(e.data);\n                _context18.next = 13;\n                break;\n\n              case 10:\n                _context18.prev = 10;\n                _context18.t0 = _context18[\"catch\"](6);\n                throw new TonConnectError(\"Bridge message parse failed, message \".concat(_context18.t0.data));\n\n              case 13:\n                this.listener(bridgeIncomingMessage);\n\n              case 14:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this, [[6, 10]]);\n      }));\n    }\n  }]);\n\n  return BridgeGateway;\n}();\n/**\n * Creates an event source.\n * @param {CreateEventSourceConfig} config - Configuration for creating an event source.\n */\n\n\nfunction createEventSource(config) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee21() {\n    var _this19 = this;\n\n    return _regeneratorRuntime.wrap(function _callee21$(_context21) {\n      while (1) {\n        switch (_context21.prev = _context21.next) {\n          case 0:\n            _context21.next = 2;\n            return timeout(function (resolve, reject, deferOptions) {\n              return __awaiter(_this19, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee20() {\n                var _this20 = this;\n\n                var _a, abortController, signal, url, lastEventId, eventSource;\n\n                return _regeneratorRuntime.wrap(function _callee20$(_context20) {\n                  while (1) {\n                    switch (_context20.prev = _context20.next) {\n                      case 0:\n                        abortController = createAbortController(deferOptions.signal);\n                        signal = abortController.signal;\n\n                        if (!signal.aborted) {\n                          _context20.next = 5;\n                          break;\n                        }\n\n                        reject(new TonConnectError('Bridge connection aborted'));\n                        return _context20.abrupt(\"return\");\n\n                      case 5:\n                        url = new URL(addPathToUrl(config.bridgeUrl, config.ssePath));\n                        url.searchParams.append('client_id', config.sessionId);\n                        _context20.next = 9;\n                        return config.bridgeGatewayStorage.getLastEventId();\n\n                      case 9:\n                        lastEventId = _context20.sent;\n\n                        if (lastEventId) {\n                          url.searchParams.append('last_event_id', lastEventId);\n                        }\n\n                        if (!signal.aborted) {\n                          _context20.next = 14;\n                          break;\n                        }\n\n                        reject(new TonConnectError('Bridge connection aborted'));\n                        return _context20.abrupt(\"return\");\n\n                      case 14:\n                        eventSource = new EventSource(url.toString());\n\n                        eventSource.onerror = function (reason) {\n                          return __awaiter(_this20, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee19() {\n                            var newInstance;\n                            return _regeneratorRuntime.wrap(function _callee19$(_context19) {\n                              while (1) {\n                                switch (_context19.prev = _context19.next) {\n                                  case 0:\n                                    if (!signal.aborted) {\n                                      _context19.next = 4;\n                                      break;\n                                    }\n\n                                    eventSource.close();\n                                    reject(new TonConnectError('Bridge connection aborted'));\n                                    return _context19.abrupt(\"return\");\n\n                                  case 4:\n                                    _context19.prev = 4;\n                                    _context19.next = 7;\n                                    return config.errorHandler(eventSource, reason);\n\n                                  case 7:\n                                    newInstance = _context19.sent;\n\n                                    if (newInstance !== eventSource) {\n                                      eventSource.close();\n                                    }\n\n                                    if (newInstance && newInstance !== eventSource) {\n                                      resolve(newInstance);\n                                    }\n\n                                    _context19.next = 16;\n                                    break;\n\n                                  case 12:\n                                    _context19.prev = 12;\n                                    _context19.t0 = _context19[\"catch\"](4);\n                                    eventSource.close();\n                                    reject(_context19.t0);\n\n                                  case 16:\n                                  case \"end\":\n                                    return _context19.stop();\n                                }\n                              }\n                            }, _callee19, null, [[4, 12]]);\n                          }));\n                        };\n\n                        eventSource.onopen = function () {\n                          if (signal.aborted) {\n                            eventSource.close();\n                            reject(new TonConnectError('Bridge connection aborted'));\n                            return;\n                          }\n\n                          resolve(eventSource);\n                        };\n\n                        eventSource.onmessage = function (event) {\n                          if (signal.aborted) {\n                            eventSource.close();\n                            reject(new TonConnectError('Bridge connection aborted'));\n                            return;\n                          }\n\n                          config.messageHandler(event);\n                        };\n\n                        (_a = config.signal) === null || _a === void 0 ? void 0 : _a.addEventListener('abort', function () {\n                          eventSource.close();\n                          reject(new TonConnectError('Bridge connection aborted'));\n                        });\n\n                      case 19:\n                      case \"end\":\n                        return _context20.stop();\n                    }\n                  }\n                }, _callee20);\n              }));\n            }, {\n              timeout: config.openingDeadlineMS,\n              signal: config.signal\n            });\n\n          case 2:\n            return _context21.abrupt(\"return\", _context21.sent);\n\n          case 3:\n          case \"end\":\n            return _context21.stop();\n        }\n      }\n    }, _callee21);\n  }));\n}\n\nfunction isPendingConnectionHttp(connection) {\n  return !('connectEvent' in connection);\n}\n\nvar BridgeConnectionStorage = /*#__PURE__*/function () {\n  function BridgeConnectionStorage(storage) {\n    _classCallCheck(this, BridgeConnectionStorage);\n\n    this.storage = storage;\n    this.storeKey = 'ton-connect-storage_bridge-connection';\n  }\n\n  _createClass(BridgeConnectionStorage, [{\n    key: \"storeConnection\",\n    value: function storeConnection(connection) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee22() {\n        var rawSession, _rawConnection, rawConnection;\n\n        return _regeneratorRuntime.wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                if (!(connection.type === 'injected')) {\n                  _context22.next = 2;\n                  break;\n                }\n\n                return _context22.abrupt(\"return\", this.storage.setItem(this.storeKey, JSON.stringify(connection)));\n\n              case 2:\n                if (isPendingConnectionHttp(connection)) {\n                  _context22.next = 6;\n                  break;\n                }\n\n                rawSession = {\n                  sessionKeyPair: connection.session.sessionCrypto.stringifyKeypair(),\n                  walletPublicKey: connection.session.walletPublicKey,\n                  bridgeUrl: connection.session.bridgeUrl\n                };\n                _rawConnection = {\n                  type: 'http',\n                  connectEvent: connection.connectEvent,\n                  session: rawSession,\n                  lastWalletEventId: connection.lastWalletEventId,\n                  nextRpcRequestId: connection.nextRpcRequestId\n                };\n                return _context22.abrupt(\"return\", this.storage.setItem(this.storeKey, JSON.stringify(_rawConnection)));\n\n              case 6:\n                rawConnection = {\n                  type: 'http',\n                  connectionSource: connection.connectionSource,\n                  sessionCrypto: connection.sessionCrypto.stringifyKeypair()\n                };\n                return _context22.abrupt(\"return\", this.storage.setItem(this.storeKey, JSON.stringify(rawConnection)));\n\n              case 8:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22, this);\n      }));\n    }\n  }, {\n    key: \"removeConnection\",\n    value: function removeConnection() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee23() {\n        return _regeneratorRuntime.wrap(function _callee23$(_context23) {\n          while (1) {\n            switch (_context23.prev = _context23.next) {\n              case 0:\n                return _context23.abrupt(\"return\", this.storage.removeItem(this.storeKey));\n\n              case 1:\n              case \"end\":\n                return _context23.stop();\n            }\n          }\n        }, _callee23, this);\n      }));\n    }\n  }, {\n    key: \"getConnection\",\n    value: function getConnection() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee24() {\n        var stored, connection, sessionCrypto;\n        return _regeneratorRuntime.wrap(function _callee24$(_context24) {\n          while (1) {\n            switch (_context24.prev = _context24.next) {\n              case 0:\n                _context24.next = 2;\n                return this.storage.getItem(this.storeKey);\n\n              case 2:\n                stored = _context24.sent;\n\n                if (stored) {\n                  _context24.next = 5;\n                  break;\n                }\n\n                return _context24.abrupt(\"return\", null);\n\n              case 5:\n                connection = JSON.parse(stored);\n\n                if (!(connection.type === 'injected')) {\n                  _context24.next = 8;\n                  break;\n                }\n\n                return _context24.abrupt(\"return\", connection);\n\n              case 8:\n                if (!('connectEvent' in connection)) {\n                  _context24.next = 11;\n                  break;\n                }\n\n                sessionCrypto = new SessionCrypto(connection.session.sessionKeyPair);\n                return _context24.abrupt(\"return\", {\n                  type: 'http',\n                  connectEvent: connection.connectEvent,\n                  lastWalletEventId: connection.lastWalletEventId,\n                  nextRpcRequestId: connection.nextRpcRequestId,\n                  session: {\n                    sessionCrypto: sessionCrypto,\n                    bridgeUrl: connection.session.bridgeUrl,\n                    walletPublicKey: connection.session.walletPublicKey\n                  }\n                });\n\n              case 11:\n                return _context24.abrupt(\"return\", {\n                  type: 'http',\n                  sessionCrypto: new SessionCrypto(connection.sessionCrypto),\n                  connectionSource: connection.connectionSource\n                });\n\n              case 12:\n              case \"end\":\n                return _context24.stop();\n            }\n          }\n        }, _callee24, this);\n      }));\n    }\n  }, {\n    key: \"getHttpConnection\",\n    value: function getHttpConnection() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee25() {\n        var connection;\n        return _regeneratorRuntime.wrap(function _callee25$(_context25) {\n          while (1) {\n            switch (_context25.prev = _context25.next) {\n              case 0:\n                _context25.next = 2;\n                return this.getConnection();\n\n              case 2:\n                connection = _context25.sent;\n\n                if (connection) {\n                  _context25.next = 5;\n                  break;\n                }\n\n                throw new TonConnectError('Trying to read HTTP connection source while nothing is stored');\n\n              case 5:\n                if (!(connection.type === 'injected')) {\n                  _context25.next = 7;\n                  break;\n                }\n\n                throw new TonConnectError('Trying to read HTTP connection source while injected connection is stored');\n\n              case 7:\n                return _context25.abrupt(\"return\", connection);\n\n              case 8:\n              case \"end\":\n                return _context25.stop();\n            }\n          }\n        }, _callee25, this);\n      }));\n    }\n  }, {\n    key: \"getHttpPendingConnection\",\n    value: function getHttpPendingConnection() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee26() {\n        var connection;\n        return _regeneratorRuntime.wrap(function _callee26$(_context26) {\n          while (1) {\n            switch (_context26.prev = _context26.next) {\n              case 0:\n                _context26.next = 2;\n                return this.getConnection();\n\n              case 2:\n                connection = _context26.sent;\n\n                if (connection) {\n                  _context26.next = 5;\n                  break;\n                }\n\n                throw new TonConnectError('Trying to read HTTP connection source while nothing is stored');\n\n              case 5:\n                if (!(connection.type === 'injected')) {\n                  _context26.next = 7;\n                  break;\n                }\n\n                throw new TonConnectError('Trying to read HTTP connection source while injected connection is stored');\n\n              case 7:\n                if (isPendingConnectionHttp(connection)) {\n                  _context26.next = 9;\n                  break;\n                }\n\n                throw new TonConnectError('Trying to read HTTP-pending connection while http connection is stored');\n\n              case 9:\n                return _context26.abrupt(\"return\", connection);\n\n              case 10:\n              case \"end\":\n                return _context26.stop();\n            }\n          }\n        }, _callee26, this);\n      }));\n    }\n  }, {\n    key: \"getInjectedConnection\",\n    value: function getInjectedConnection() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee27() {\n        var connection;\n        return _regeneratorRuntime.wrap(function _callee27$(_context27) {\n          while (1) {\n            switch (_context27.prev = _context27.next) {\n              case 0:\n                _context27.next = 2;\n                return this.getConnection();\n\n              case 2:\n                connection = _context27.sent;\n\n                if (connection) {\n                  _context27.next = 5;\n                  break;\n                }\n\n                throw new TonConnectError('Trying to read Injected bridge connection source while nothing is stored');\n\n              case 5:\n                if (!((connection === null || connection === void 0 ? void 0 : connection.type) === 'http')) {\n                  _context27.next = 7;\n                  break;\n                }\n\n                throw new TonConnectError('Trying to read Injected bridge connection source while HTTP connection is stored');\n\n              case 7:\n                return _context27.abrupt(\"return\", connection);\n\n              case 8:\n              case \"end\":\n                return _context27.stop();\n            }\n          }\n        }, _callee27, this);\n      }));\n    }\n  }, {\n    key: \"storedConnectionType\",\n    value: function storedConnectionType() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee28() {\n        var stored, connection;\n        return _regeneratorRuntime.wrap(function _callee28$(_context28) {\n          while (1) {\n            switch (_context28.prev = _context28.next) {\n              case 0:\n                _context28.next = 2;\n                return this.storage.getItem(this.storeKey);\n\n              case 2:\n                stored = _context28.sent;\n\n                if (stored) {\n                  _context28.next = 5;\n                  break;\n                }\n\n                return _context28.abrupt(\"return\", null);\n\n              case 5:\n                connection = JSON.parse(stored);\n                return _context28.abrupt(\"return\", connection.type);\n\n              case 7:\n              case \"end\":\n                return _context28.stop();\n            }\n          }\n        }, _callee28, this);\n      }));\n    }\n  }, {\n    key: \"storeLastWalletEventId\",\n    value: function storeLastWalletEventId(id) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee29() {\n        var connection;\n        return _regeneratorRuntime.wrap(function _callee29$(_context29) {\n          while (1) {\n            switch (_context29.prev = _context29.next) {\n              case 0:\n                _context29.next = 2;\n                return this.getConnection();\n\n              case 2:\n                connection = _context29.sent;\n\n                if (!(connection && connection.type === 'http' && !isPendingConnectionHttp(connection))) {\n                  _context29.next = 6;\n                  break;\n                }\n\n                connection.lastWalletEventId = id;\n                return _context29.abrupt(\"return\", this.storeConnection(connection));\n\n              case 6:\n              case \"end\":\n                return _context29.stop();\n            }\n          }\n        }, _callee29, this);\n      }));\n    }\n  }, {\n    key: \"getLastWalletEventId\",\n    value: function getLastWalletEventId() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee30() {\n        var connection;\n        return _regeneratorRuntime.wrap(function _callee30$(_context30) {\n          while (1) {\n            switch (_context30.prev = _context30.next) {\n              case 0:\n                _context30.next = 2;\n                return this.getConnection();\n\n              case 2:\n                connection = _context30.sent;\n\n                if (!(connection && 'lastWalletEventId' in connection)) {\n                  _context30.next = 5;\n                  break;\n                }\n\n                return _context30.abrupt(\"return\", connection.lastWalletEventId);\n\n              case 5:\n                return _context30.abrupt(\"return\", undefined);\n\n              case 6:\n              case \"end\":\n                return _context30.stop();\n            }\n          }\n        }, _callee30, this);\n      }));\n    }\n  }, {\n    key: \"increaseNextRpcRequestId\",\n    value: function increaseNextRpcRequestId() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee31() {\n        var connection, lastId;\n        return _regeneratorRuntime.wrap(function _callee31$(_context31) {\n          while (1) {\n            switch (_context31.prev = _context31.next) {\n              case 0:\n                _context31.next = 2;\n                return this.getConnection();\n\n              case 2:\n                connection = _context31.sent;\n\n                if (!(connection && 'nextRpcRequestId' in connection)) {\n                  _context31.next = 7;\n                  break;\n                }\n\n                lastId = connection.nextRpcRequestId || 0;\n                connection.nextRpcRequestId = lastId + 1;\n                return _context31.abrupt(\"return\", this.storeConnection(connection));\n\n              case 7:\n              case \"end\":\n                return _context31.stop();\n            }\n          }\n        }, _callee31, this);\n      }));\n    }\n  }, {\n    key: \"getNextRpcRequestId\",\n    value: function getNextRpcRequestId() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee32() {\n        var connection;\n        return _regeneratorRuntime.wrap(function _callee32$(_context32) {\n          while (1) {\n            switch (_context32.prev = _context32.next) {\n              case 0:\n                _context32.next = 2;\n                return this.getConnection();\n\n              case 2:\n                connection = _context32.sent;\n\n                if (!(connection && 'nextRpcRequestId' in connection)) {\n                  _context32.next = 5;\n                  break;\n                }\n\n                return _context32.abrupt(\"return\", connection.nextRpcRequestId || 0);\n\n              case 5:\n                return _context32.abrupt(\"return\", 0);\n\n              case 6:\n              case \"end\":\n                return _context32.stop();\n            }\n          }\n        }, _callee32, this);\n      }));\n    }\n  }]);\n\n  return BridgeConnectionStorage;\n}();\n\nvar PROTOCOL_VERSION = 2;\n\nvar BridgeProvider = /*#__PURE__*/function () {\n  function BridgeProvider(storage, walletConnectionSource) {\n    _classCallCheck(this, BridgeProvider);\n\n    this.storage = storage;\n    this.walletConnectionSource = walletConnectionSource;\n    this.type = 'http';\n    this.standardUniversalLink = 'tc://';\n    this.pendingRequests = new Map();\n    this.session = null;\n    this.gateway = null;\n    this.pendingGateways = [];\n    this.listeners = [];\n    this.defaultOpeningDeadlineMS = 5000;\n    this.connectionStorage = new BridgeConnectionStorage(storage);\n  }\n\n  _createClass(BridgeProvider, [{\n    key: \"connect\",\n    value: function connect(message, options) {\n      var _this21 = this;\n\n      var _a;\n\n      var abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n      (_a = this.abortController) === null || _a === void 0 ? void 0 : _a.abort();\n      this.abortController = abortController;\n      this.closeGateways();\n      var sessionCrypto = new SessionCrypto();\n      this.session = {\n        sessionCrypto: sessionCrypto,\n        bridgeUrl: 'bridgeUrl' in this.walletConnectionSource ? this.walletConnectionSource.bridgeUrl : ''\n      };\n      this.connectionStorage.storeConnection({\n        type: 'http',\n        connectionSource: this.walletConnectionSource,\n        sessionCrypto: sessionCrypto\n      }).then(function () {\n        return __awaiter(_this21, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee33() {\n          var _this22 = this;\n\n          return _regeneratorRuntime.wrap(function _callee33$(_context33) {\n            while (1) {\n              switch (_context33.prev = _context33.next) {\n                case 0:\n                  if (!abortController.signal.aborted) {\n                    _context33.next = 2;\n                    break;\n                  }\n\n                  return _context33.abrupt(\"return\");\n\n                case 2:\n                  _context33.next = 4;\n                  return callForSuccess(function (_options) {\n                    return _this22.openGateways(sessionCrypto, {\n                      openingDeadlineMS: options === null || options === void 0 ? void 0 : options.openingDeadlineMS,\n                      signal: _options === null || _options === void 0 ? void 0 : _options.signal\n                    });\n                  }, {\n                    attempts: Number.MAX_SAFE_INTEGER,\n                    delayMs: 5000,\n                    signal: abortController.signal\n                  });\n\n                case 4:\n                case \"end\":\n                  return _context33.stop();\n              }\n            }\n          }, _callee33);\n        }));\n      });\n      var universalLink = 'universalLink' in this.walletConnectionSource && this.walletConnectionSource.universalLink ? this.walletConnectionSource.universalLink : this.standardUniversalLink;\n      return this.generateUniversalLink(universalLink, message);\n    }\n  }, {\n    key: \"restoreConnection\",\n    value: function restoreConnection(options) {\n      var _a, _b;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee34() {\n        var _this23 = this;\n\n        var abortController, storedConnection, openingDeadlineMS;\n        return _regeneratorRuntime.wrap(function _callee34$(_context34) {\n          while (1) {\n            switch (_context34.prev = _context34.next) {\n              case 0:\n                abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n                (_a = this.abortController) === null || _a === void 0 ? void 0 : _a.abort();\n                this.abortController = abortController;\n\n                if (!abortController.signal.aborted) {\n                  _context34.next = 5;\n                  break;\n                }\n\n                return _context34.abrupt(\"return\");\n\n              case 5:\n                this.closeGateways();\n                _context34.next = 8;\n                return this.connectionStorage.getHttpConnection();\n\n              case 8:\n                storedConnection = _context34.sent;\n\n                if (storedConnection) {\n                  _context34.next = 11;\n                  break;\n                }\n\n                return _context34.abrupt(\"return\");\n\n              case 11:\n                if (!abortController.signal.aborted) {\n                  _context34.next = 13;\n                  break;\n                }\n\n                return _context34.abrupt(\"return\");\n\n              case 13:\n                openingDeadlineMS = (_b = options === null || options === void 0 ? void 0 : options.openingDeadlineMS) !== null && _b !== void 0 ? _b : this.defaultOpeningDeadlineMS;\n\n                if (!isPendingConnectionHttp(storedConnection)) {\n                  _context34.next = 19;\n                  break;\n                }\n\n                this.session = {\n                  sessionCrypto: storedConnection.sessionCrypto,\n                  bridgeUrl: 'bridgeUrl' in this.walletConnectionSource ? this.walletConnectionSource.bridgeUrl : ''\n                };\n                _context34.next = 18;\n                return this.openGateways(storedConnection.sessionCrypto, {\n                  openingDeadlineMS: openingDeadlineMS,\n                  signal: abortController === null || abortController === void 0 ? void 0 : abortController.signal\n                });\n\n              case 18:\n                return _context34.abrupt(\"return\", _context34.sent);\n\n              case 19:\n                if (!Array.isArray(this.walletConnectionSource)) {\n                  _context34.next = 21;\n                  break;\n                }\n\n                throw new TonConnectError('Internal error. Connection source is array while WalletConnectionSourceHTTP was expected.');\n\n              case 21:\n                this.session = storedConnection.session;\n\n                if (!this.gateway) {\n                  _context34.next = 26;\n                  break;\n                }\n\n                logDebug('Gateway is already opened, closing previous gateway');\n                _context34.next = 26;\n                return this.gateway.close();\n\n              case 26:\n                this.gateway = new BridgeGateway(this.storage, this.walletConnectionSource.bridgeUrl, storedConnection.session.sessionCrypto.sessionId, this.gatewayListener.bind(this), this.gatewayErrorsListener.bind(this));\n\n                if (!abortController.signal.aborted) {\n                  _context34.next = 29;\n                  break;\n                }\n\n                return _context34.abrupt(\"return\");\n\n              case 29:\n                // notify listeners about stored connection\n                this.listeners.forEach(function (listener) {\n                  return listener(storedConnection.connectEvent);\n                }); // wait for the connection to be opened\n\n                _context34.prev = 30;\n                _context34.next = 33;\n                return callForSuccess(function (options) {\n                  return _this23.gateway.registerSession({\n                    openingDeadlineMS: openingDeadlineMS,\n                    signal: options.signal\n                  });\n                }, {\n                  attempts: Number.MAX_SAFE_INTEGER,\n                  delayMs: 5000,\n                  signal: abortController.signal\n                });\n\n              case 33:\n                _context34.next = 40;\n                break;\n\n              case 35:\n                _context34.prev = 35;\n                _context34.t0 = _context34[\"catch\"](30);\n                _context34.next = 39;\n                return this.disconnect({\n                  signal: abortController.signal\n                });\n\n              case 39:\n                return _context34.abrupt(\"return\");\n\n              case 40:\n              case \"end\":\n                return _context34.stop();\n            }\n          }\n        }, _callee34, this, [[30, 35]]);\n      }));\n    }\n  }, {\n    key: \"sendRequest\",\n    value: function sendRequest(request, optionsOrOnRequestSent) {\n      var _this24 = this;\n\n      // TODO: remove deprecated method\n      var options = {};\n\n      if (typeof optionsOrOnRequestSent === 'function') {\n        options.onRequestSent = optionsOrOnRequestSent;\n      } else {\n        options.onRequestSent = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.onRequestSent;\n        options.signal = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.signal;\n        options.attempts = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.attempts;\n      }\n\n      return new Promise(function (resolve, reject) {\n        return __awaiter(_this24, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee35() {\n          var _a, id, encodedRequest;\n\n          return _regeneratorRuntime.wrap(function _callee35$(_context35) {\n            while (1) {\n              switch (_context35.prev = _context35.next) {\n                case 0:\n                  if (!(!this.gateway || !this.session || !('walletPublicKey' in this.session))) {\n                    _context35.next = 2;\n                    break;\n                  }\n\n                  throw new TonConnectError('Trying to send bridge request without session');\n\n                case 2:\n                  _context35.next = 4;\n                  return this.connectionStorage.getNextRpcRequestId();\n\n                case 4:\n                  id = _context35.sent.toString();\n                  _context35.next = 7;\n                  return this.connectionStorage.increaseNextRpcRequestId();\n\n                case 7:\n                  logDebug('Send http-bridge request:', Object.assign(Object.assign({}, request), {\n                    id: id\n                  }));\n                  encodedRequest = this.session.sessionCrypto.encrypt(JSON.stringify(Object.assign(Object.assign({}, request), {\n                    id: id\n                  })), hexToByteArray(this.session.walletPublicKey));\n                  _context35.prev = 9;\n                  _context35.next = 12;\n                  return this.gateway.send(encodedRequest, this.session.walletPublicKey, request.method, {\n                    attempts: options === null || options === void 0 ? void 0 : options.attempts,\n                    signal: options === null || options === void 0 ? void 0 : options.signal\n                  });\n\n                case 12:\n                  (_a = options === null || options === void 0 ? void 0 : options.onRequestSent) === null || _a === void 0 ? void 0 : _a.call(options);\n                  this.pendingRequests.set(id.toString(), resolve);\n                  _context35.next = 19;\n                  break;\n\n                case 16:\n                  _context35.prev = 16;\n                  _context35.t0 = _context35[\"catch\"](9);\n                  reject(_context35.t0);\n\n                case 19:\n                case \"end\":\n                  return _context35.stop();\n              }\n            }\n          }, _callee35, this, [[9, 16]]);\n        }));\n      });\n    }\n  }, {\n    key: \"closeConnection\",\n    value: function closeConnection() {\n      this.closeGateways();\n      this.listeners = [];\n      this.session = null;\n      this.gateway = null;\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect(options) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee37() {\n        var _this25 = this;\n\n        return _regeneratorRuntime.wrap(function _callee37$(_context37) {\n          while (1) {\n            switch (_context37.prev = _context37.next) {\n              case 0:\n                return _context37.abrupt(\"return\", new Promise(function (resolve) {\n                  return __awaiter(_this25, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee36() {\n                    var _this26 = this;\n\n                    var called, timeoutId, onRequestSent, abortController;\n                    return _regeneratorRuntime.wrap(function _callee36$(_context36) {\n                      while (1) {\n                        switch (_context36.prev = _context36.next) {\n                          case 0:\n                            called = false;\n                            timeoutId = null;\n\n                            onRequestSent = function onRequestSent() {\n                              if (!called) {\n                                called = true;\n\n                                _this26.removeBridgeAndSession().then(resolve);\n                              }\n                            };\n\n                            _context36.prev = 3;\n                            this.closeGateways();\n                            abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n                            timeoutId = setTimeout(function () {\n                              abortController.abort();\n                            }, this.defaultOpeningDeadlineMS);\n                            _context36.next = 9;\n                            return this.sendRequest({\n                              method: 'disconnect',\n                              params: []\n                            }, {\n                              onRequestSent: onRequestSent,\n                              signal: abortController.signal,\n                              attempts: 1\n                            });\n\n                          case 9:\n                            _context36.next = 15;\n                            break;\n\n                          case 11:\n                            _context36.prev = 11;\n                            _context36.t0 = _context36[\"catch\"](3);\n                            logDebug('Disconnect error:', _context36.t0);\n\n                            if (!called) {\n                              this.removeBridgeAndSession().then(resolve);\n                            }\n\n                          case 15:\n                            _context36.prev = 15;\n\n                            if (timeoutId) {\n                              clearTimeout(timeoutId);\n                            }\n\n                            onRequestSent();\n                            return _context36.finish(15);\n\n                          case 19:\n                          case \"end\":\n                            return _context36.stop();\n                        }\n                      }\n                    }, _callee36, this, [[3, 11, 15, 19]]);\n                  }));\n                }));\n\n              case 1:\n              case \"end\":\n                return _context37.stop();\n            }\n          }\n        }, _callee37);\n      }));\n    }\n  }, {\n    key: \"listen\",\n    value: function listen(callback) {\n      var _this27 = this;\n\n      this.listeners.push(callback);\n      return function () {\n        return _this27.listeners = _this27.listeners.filter(function (listener) {\n          return listener !== callback;\n        });\n      };\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      var _a;\n\n      (_a = this.gateway) === null || _a === void 0 ? void 0 : _a.pause();\n      this.pendingGateways.forEach(function (bridge) {\n        return bridge.pause();\n      });\n    }\n  }, {\n    key: \"unPause\",\n    value: function unPause() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee38() {\n        var promises;\n        return _regeneratorRuntime.wrap(function _callee38$(_context38) {\n          while (1) {\n            switch (_context38.prev = _context38.next) {\n              case 0:\n                promises = this.pendingGateways.map(function (bridge) {\n                  return bridge.unPause();\n                });\n\n                if (this.gateway) {\n                  promises.push(this.gateway.unPause());\n                }\n\n                _context38.next = 4;\n                return Promise.all(promises);\n\n              case 4:\n              case \"end\":\n                return _context38.stop();\n            }\n          }\n        }, _callee38, this);\n      }));\n    }\n  }, {\n    key: \"pendingGatewaysListener\",\n    value: function pendingGatewaysListener(gateway, bridgeUrl, bridgeIncomingMessage) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee39() {\n        return _regeneratorRuntime.wrap(function _callee39$(_context39) {\n          while (1) {\n            switch (_context39.prev = _context39.next) {\n              case 0:\n                if (this.pendingGateways.includes(gateway)) {\n                  _context39.next = 4;\n                  break;\n                }\n\n                _context39.next = 3;\n                return gateway.close();\n\n              case 3:\n                return _context39.abrupt(\"return\");\n\n              case 4:\n                this.closeGateways({\n                  except: gateway\n                });\n\n                if (!this.gateway) {\n                  _context39.next = 9;\n                  break;\n                }\n\n                logDebug('Gateway is already opened, closing previous gateway');\n                _context39.next = 9;\n                return this.gateway.close();\n\n              case 9:\n                this.session.bridgeUrl = bridgeUrl;\n                this.gateway = gateway;\n                this.gateway.setErrorsListener(this.gatewayErrorsListener.bind(this));\n                this.gateway.setListener(this.gatewayListener.bind(this));\n                return _context39.abrupt(\"return\", this.gatewayListener(bridgeIncomingMessage));\n\n              case 14:\n              case \"end\":\n                return _context39.stop();\n            }\n          }\n        }, _callee39, this);\n      }));\n    }\n  }, {\n    key: \"gatewayListener\",\n    value: function gatewayListener(bridgeIncomingMessage) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee40() {\n        var walletMessage, id, resolve, lastId, listeners;\n        return _regeneratorRuntime.wrap(function _callee40$(_context40) {\n          while (1) {\n            switch (_context40.prev = _context40.next) {\n              case 0:\n                walletMessage = JSON.parse(this.session.sessionCrypto.decrypt(Base64.decode(bridgeIncomingMessage.message).toUint8Array(), hexToByteArray(bridgeIncomingMessage.from)));\n                logDebug('Wallet message received:', walletMessage);\n\n                if ('event' in walletMessage) {\n                  _context40.next = 11;\n                  break;\n                }\n\n                id = walletMessage.id.toString();\n                resolve = this.pendingRequests.get(id);\n\n                if (resolve) {\n                  _context40.next = 8;\n                  break;\n                }\n\n                logDebug(\"Response id \".concat(id, \" doesn't match any request's id\"));\n                return _context40.abrupt(\"return\");\n\n              case 8:\n                resolve(walletMessage);\n                this.pendingRequests.delete(id);\n                return _context40.abrupt(\"return\");\n\n              case 11:\n                if (!(walletMessage.id !== undefined)) {\n                  _context40.next = 21;\n                  break;\n                }\n\n                _context40.next = 14;\n                return this.connectionStorage.getLastWalletEventId();\n\n              case 14:\n                lastId = _context40.sent;\n\n                if (!(lastId !== undefined && walletMessage.id <= lastId)) {\n                  _context40.next = 18;\n                  break;\n                }\n\n                logError(\"Received event id (=\".concat(walletMessage.id, \") must be greater than stored last wallet event id (=\").concat(lastId, \") \"));\n                return _context40.abrupt(\"return\");\n\n              case 18:\n                if (!(walletMessage.event !== 'connect')) {\n                  _context40.next = 21;\n                  break;\n                }\n\n                _context40.next = 21;\n                return this.connectionStorage.storeLastWalletEventId(walletMessage.id);\n\n              case 21:\n                // `this.listeners` might be modified in the event handler\n                listeners = this.listeners;\n\n                if (!(walletMessage.event === 'connect')) {\n                  _context40.next = 25;\n                  break;\n                }\n\n                _context40.next = 25;\n                return this.updateSession(walletMessage, bridgeIncomingMessage.from);\n\n              case 25:\n                if (!(walletMessage.event === 'disconnect')) {\n                  _context40.next = 29;\n                  break;\n                }\n\n                logDebug(\"Removing bridge and session: received disconnect event\");\n                _context40.next = 29;\n                return this.removeBridgeAndSession();\n\n              case 29:\n                listeners.forEach(function (listener) {\n                  return listener(walletMessage);\n                });\n\n              case 30:\n              case \"end\":\n                return _context40.stop();\n            }\n          }\n        }, _callee40, this);\n      }));\n    }\n  }, {\n    key: \"gatewayErrorsListener\",\n    value: function gatewayErrorsListener(e) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee41() {\n        return _regeneratorRuntime.wrap(function _callee41$(_context41) {\n          while (1) {\n            switch (_context41.prev = _context41.next) {\n              case 0:\n                throw new TonConnectError(\"Bridge error \".concat(JSON.stringify(e)));\n\n              case 1:\n              case \"end\":\n                return _context41.stop();\n            }\n          }\n        }, _callee41);\n      }));\n    }\n  }, {\n    key: \"updateSession\",\n    value: function updateSession(connectEvent, walletPublicKey) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee42() {\n        var tonAddrItem, connectEventToSave;\n        return _regeneratorRuntime.wrap(function _callee42$(_context42) {\n          while (1) {\n            switch (_context42.prev = _context42.next) {\n              case 0:\n                this.session = Object.assign(Object.assign({}, this.session), {\n                  walletPublicKey: walletPublicKey\n                });\n                tonAddrItem = connectEvent.payload.items.find(function (item) {\n                  return item.name === 'ton_addr';\n                });\n                connectEventToSave = Object.assign(Object.assign({}, connectEvent), {\n                  payload: Object.assign(Object.assign({}, connectEvent.payload), {\n                    items: [tonAddrItem]\n                  })\n                });\n                _context42.next = 5;\n                return this.connectionStorage.storeConnection({\n                  type: 'http',\n                  session: this.session,\n                  lastWalletEventId: connectEvent.id,\n                  connectEvent: connectEventToSave,\n                  nextRpcRequestId: 0\n                });\n\n              case 5:\n              case \"end\":\n                return _context42.stop();\n            }\n          }\n        }, _callee42, this);\n      }));\n    }\n  }, {\n    key: \"removeBridgeAndSession\",\n    value: function removeBridgeAndSession() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee43() {\n        return _regeneratorRuntime.wrap(function _callee43$(_context43) {\n          while (1) {\n            switch (_context43.prev = _context43.next) {\n              case 0:\n                this.closeConnection();\n                _context43.next = 3;\n                return this.connectionStorage.removeConnection();\n\n              case 3:\n              case \"end\":\n                return _context43.stop();\n            }\n          }\n        }, _callee43, this);\n      }));\n    }\n  }, {\n    key: \"generateUniversalLink\",\n    value: function generateUniversalLink(universalLink, message) {\n      if (isTelegramUrl(universalLink)) {\n        return this.generateTGUniversalLink(universalLink, message);\n      }\n\n      return this.generateRegularUniversalLink(universalLink, message);\n    }\n  }, {\n    key: \"generateRegularUniversalLink\",\n    value: function generateRegularUniversalLink(universalLink, message) {\n      var url = new URL(universalLink);\n      url.searchParams.append('v', PROTOCOL_VERSION.toString());\n      url.searchParams.append('id', this.session.sessionCrypto.sessionId);\n      url.searchParams.append('r', JSON.stringify(message));\n      return url.toString();\n    }\n  }, {\n    key: \"generateTGUniversalLink\",\n    value: function generateTGUniversalLink(universalLink, message) {\n      var urlToWrap = this.generateRegularUniversalLink('about:blank', message);\n      var linkParams = urlToWrap.split('?')[1];\n      var startapp = 'tonconnect-' + encodeTelegramUrlParameters(linkParams); // TODO: Remove this line after all dApps and the wallets-list.json have been updated\n\n      var updatedUniversalLink = this.convertToDirectLink(universalLink);\n      var url = new URL(updatedUniversalLink);\n      url.searchParams.append('startapp', startapp);\n      return url.toString();\n    } // TODO: Remove this method after all dApps and the wallets-list.json have been updated\n\n  }, {\n    key: \"convertToDirectLink\",\n    value: function convertToDirectLink(universalLink) {\n      var url = new URL(universalLink);\n\n      if (url.searchParams.has('attach')) {\n        url.searchParams.delete('attach');\n        url.pathname += '/start';\n      }\n\n      return url.toString();\n    }\n  }, {\n    key: \"openGateways\",\n    value: function openGateways(sessionCrypto, options) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee44() {\n        var _this28 = this;\n\n        return _regeneratorRuntime.wrap(function _callee44$(_context44) {\n          while (1) {\n            switch (_context44.prev = _context44.next) {\n              case 0:\n                if (!Array.isArray(this.walletConnectionSource)) {\n                  _context44.next = 8;\n                  break;\n                }\n\n                // close all gateways before opening new ones\n                this.pendingGateways.map(function (bridge) {\n                  return bridge.close().catch();\n                }); // open new gateways\n\n                this.pendingGateways = this.walletConnectionSource.map(function (source) {\n                  var gateway = new BridgeGateway(_this28.storage, source.bridgeUrl, sessionCrypto.sessionId, function () {}, function () {});\n                  gateway.setListener(function (message) {\n                    return _this28.pendingGatewaysListener(gateway, source.bridgeUrl, message);\n                  });\n                  return gateway;\n                });\n                _context44.next = 5;\n                return Promise.allSettled(this.pendingGateways.map(function (bridge) {\n                  return callForSuccess(function (_options) {\n                    if (!_this28.pendingGateways.some(function (item) {\n                      return item === bridge;\n                    })) {\n                      return bridge.close();\n                    }\n\n                    return bridge.registerSession({\n                      openingDeadlineMS: options === null || options === void 0 ? void 0 : options.openingDeadlineMS,\n                      signal: _options.signal\n                    });\n                  }, {\n                    attempts: Number.MAX_SAFE_INTEGER,\n                    delayMs: 5000,\n                    signal: options === null || options === void 0 ? void 0 : options.signal\n                  });\n                }));\n\n              case 5:\n                return _context44.abrupt(\"return\");\n\n              case 8:\n                if (!this.gateway) {\n                  _context44.next = 12;\n                  break;\n                }\n\n                logDebug(\"Gateway is already opened, closing previous gateway\");\n                _context44.next = 12;\n                return this.gateway.close();\n\n              case 12:\n                this.gateway = new BridgeGateway(this.storage, this.walletConnectionSource.bridgeUrl, sessionCrypto.sessionId, this.gatewayListener.bind(this), this.gatewayErrorsListener.bind(this));\n                _context44.next = 15;\n                return this.gateway.registerSession({\n                  openingDeadlineMS: options === null || options === void 0 ? void 0 : options.openingDeadlineMS,\n                  signal: options === null || options === void 0 ? void 0 : options.signal\n                });\n\n              case 15:\n                return _context44.abrupt(\"return\", _context44.sent);\n\n              case 16:\n              case \"end\":\n                return _context44.stop();\n            }\n          }\n        }, _callee44, this);\n      }));\n    }\n  }, {\n    key: \"closeGateways\",\n    value: function closeGateways(options) {\n      var _a;\n\n      (_a = this.gateway) === null || _a === void 0 ? void 0 : _a.close();\n      this.pendingGateways.filter(function (item) {\n        return item !== (options === null || options === void 0 ? void 0 : options.except);\n      }).forEach(function (bridge) {\n        return bridge.close();\n      });\n      this.pendingGateways = [];\n    }\n  }], [{\n    key: \"fromStorage\",\n    value: function fromStorage(storage) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee45() {\n        var bridgeConnectionStorage, connection;\n        return _regeneratorRuntime.wrap(function _callee45$(_context45) {\n          while (1) {\n            switch (_context45.prev = _context45.next) {\n              case 0:\n                bridgeConnectionStorage = new BridgeConnectionStorage(storage);\n                _context45.next = 3;\n                return bridgeConnectionStorage.getHttpConnection();\n\n              case 3:\n                connection = _context45.sent;\n\n                if (!isPendingConnectionHttp(connection)) {\n                  _context45.next = 6;\n                  break;\n                }\n\n                return _context45.abrupt(\"return\", new BridgeProvider(storage, connection.connectionSource));\n\n              case 6:\n                return _context45.abrupt(\"return\", new BridgeProvider(storage, {\n                  bridgeUrl: connection.session.bridgeUrl\n                }));\n\n              case 7:\n              case \"end\":\n                return _context45.stop();\n            }\n          }\n        }, _callee45);\n      }));\n    }\n  }]);\n\n  return BridgeProvider;\n}();\n\nfunction hasProperty(value, propertyKey) {\n  return hasProperties(value, [propertyKey]);\n}\n\nfunction hasProperties(value, propertyKeys) {\n  if (!value || typeof value !== 'object') {\n    return false;\n  }\n\n  return propertyKeys.every(function (propertyKey) {\n    return propertyKey in value;\n  });\n}\n\nfunction isJSBridgeWithMetadata(value) {\n  try {\n    if (!hasProperty(value, 'tonconnect') || !hasProperty(value.tonconnect, 'walletInfo')) {\n      return false;\n    }\n\n    return hasProperties(value.tonconnect.walletInfo, ['name', 'app_name', 'image', 'about_url', 'platforms']);\n  } catch (_a) {\n    return false;\n  }\n}\n/**\n * In memory storage like localStorage, but without persistence.\n * Uses as a fallback for localStorage in Safari's private mode.\n */\n\n\nvar InMemoryStorage = /*#__PURE__*/function () {\n  function InMemoryStorage() {\n    _classCallCheck(this, InMemoryStorage);\n\n    this.storage = {};\n  }\n\n  _createClass(InMemoryStorage, [{\n    key: \"length\",\n    get: function get() {\n      return Object.keys(this.storage).length;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.storage = {};\n    }\n  }, {\n    key: \"getItem\",\n    value: function getItem(key) {\n      var _a;\n\n      return (_a = this.storage[key]) !== null && _a !== void 0 ? _a : null;\n    }\n  }, {\n    key: \"key\",\n    value: function key(index) {\n      var _a;\n\n      var keys = Object.keys(this.storage);\n\n      if (index < 0 || index >= keys.length) {\n        return null;\n      }\n\n      return (_a = keys[index]) !== null && _a !== void 0 ? _a : null;\n    }\n  }, {\n    key: \"removeItem\",\n    value: function removeItem(key) {\n      delete this.storage[key];\n    }\n  }, {\n    key: \"setItem\",\n    value: function setItem(key, value) {\n      this.storage[key] = value;\n    }\n  }], [{\n    key: \"getInstance\",\n    value: function getInstance() {\n      if (!InMemoryStorage.instance) {\n        InMemoryStorage.instance = new InMemoryStorage();\n      }\n\n      return InMemoryStorage.instance;\n    }\n  }]);\n\n  return InMemoryStorage;\n}();\n\nfunction getWindow() {\n  if (typeof window === 'undefined') {\n    return undefined;\n  }\n\n  return window;\n}\n/**\n * The function try to get window keys, if it is not available it returns empty array.\n * As an example, for Safari's private mode it returns empty array, because the browser does not allow to get window keys.\n */\n\n\nfunction tryGetWindowKeys() {\n  var window = getWindow();\n\n  if (!window) {\n    return [];\n  }\n\n  try {\n    return Object.keys(window);\n  } catch (_a) {\n    return [];\n  }\n}\n\nfunction getDocument() {\n  if (typeof document === 'undefined') {\n    return undefined;\n  }\n\n  return document;\n}\n\nfunction getWebPageManifest() {\n  var _a;\n\n  var origin = (_a = getWindow()) === null || _a === void 0 ? void 0 : _a.location.origin;\n\n  if (origin) {\n    return origin + '/tonconnect-manifest.json';\n  }\n\n  return '';\n}\n/**\n * Returns `localStorage` if it is available. In Safari's private mode, it returns `InMemoryStorage`. In Node.js, it throws an error.\n */\n\n\nfunction tryGetLocalStorage() {\n  if (isLocalStorageAvailable()) {\n    return localStorage;\n  }\n\n  if (isNodeJs()) {\n    throw new TonConnectError('`localStorage` is unavailable, but it is required for TonConnect. For more details, see https://github.com/ton-connect/sdk/tree/main/packages/sdk#init-connector');\n  }\n\n  return InMemoryStorage.getInstance();\n}\n/**\n * Checks if `localStorage` is available.\n */\n\n\nfunction isLocalStorageAvailable() {\n  // We use a try/catch block because Safari's private mode throws an error when attempting to access localStorage.\n  try {\n    return typeof localStorage !== 'undefined';\n  } catch (_a) {\n    return false;\n  }\n}\n/**\n * Checks if the environment is Node.js.\n */\n\n\nfunction isNodeJs() {\n  return typeof process !== 'undefined' && process.versions != null && process.versions.node != null;\n}\n\nvar InjectedProvider = /*#__PURE__*/function () {\n  function InjectedProvider(storage, injectedWalletKey) {\n    _classCallCheck(this, InjectedProvider);\n\n    this.injectedWalletKey = injectedWalletKey;\n    this.type = 'injected';\n    this.unsubscribeCallback = null;\n    this.listenSubscriptions = false;\n    this.listeners = [];\n    var window = InjectedProvider.window;\n\n    if (!InjectedProvider.isWindowContainsWallet(window, injectedWalletKey)) {\n      throw new WalletNotInjectedError();\n    }\n\n    this.connectionStorage = new BridgeConnectionStorage(storage);\n    this.injectedWallet = window[injectedWalletKey].tonconnect;\n  }\n\n  _createClass(InjectedProvider, [{\n    key: \"connect\",\n    value: function connect(message) {\n      this._connect(PROTOCOL_VERSION, message);\n    }\n  }, {\n    key: \"restoreConnection\",\n    value: function restoreConnection() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee46() {\n        var connectEvent;\n        return _regeneratorRuntime.wrap(function _callee46$(_context46) {\n          while (1) {\n            switch (_context46.prev = _context46.next) {\n              case 0:\n                _context46.prev = 0;\n                logDebug(\"Injected Provider restoring connection...\");\n                _context46.next = 4;\n                return this.injectedWallet.restoreConnection();\n\n              case 4:\n                connectEvent = _context46.sent;\n                logDebug('Injected Provider restoring connection response', connectEvent);\n\n                if (!(connectEvent.event === 'connect')) {\n                  _context46.next = 11;\n                  break;\n                }\n\n                this.makeSubscriptions();\n                this.listeners.forEach(function (listener) {\n                  return listener(connectEvent);\n                });\n                _context46.next = 13;\n                break;\n\n              case 11:\n                _context46.next = 13;\n                return this.connectionStorage.removeConnection();\n\n              case 13:\n                _context46.next = 20;\n                break;\n\n              case 15:\n                _context46.prev = 15;\n                _context46.t0 = _context46[\"catch\"](0);\n                _context46.next = 19;\n                return this.connectionStorage.removeConnection();\n\n              case 19:\n                console.error(_context46.t0);\n\n              case 20:\n              case \"end\":\n                return _context46.stop();\n            }\n          }\n        }, _callee46, this, [[0, 15]]);\n      }));\n    }\n  }, {\n    key: \"closeConnection\",\n    value: function closeConnection() {\n      if (this.listenSubscriptions) {\n        this.injectedWallet.disconnect();\n      }\n\n      this.closeAllListeners();\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee47() {\n        var _this29 = this;\n\n        return _regeneratorRuntime.wrap(function _callee47$(_context47) {\n          while (1) {\n            switch (_context47.prev = _context47.next) {\n              case 0:\n                return _context47.abrupt(\"return\", new Promise(function (resolve) {\n                  var onRequestSent = function onRequestSent() {\n                    _this29.closeAllListeners();\n\n                    _this29.connectionStorage.removeConnection().then(resolve);\n                  };\n\n                  try {\n                    _this29.injectedWallet.disconnect();\n\n                    onRequestSent();\n                  } catch (e) {\n                    logDebug(e);\n\n                    _this29.sendRequest({\n                      method: 'disconnect',\n                      params: []\n                    }, onRequestSent);\n                  }\n                }));\n\n              case 1:\n              case \"end\":\n                return _context47.stop();\n            }\n          }\n        }, _callee47);\n      }));\n    }\n  }, {\n    key: \"closeAllListeners\",\n    value: function closeAllListeners() {\n      var _a;\n\n      this.listenSubscriptions = false;\n      this.listeners = [];\n      (_a = this.unsubscribeCallback) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n  }, {\n    key: \"listen\",\n    value: function listen(eventsCallback) {\n      var _this30 = this;\n\n      this.listeners.push(eventsCallback);\n      return function () {\n        return _this30.listeners = _this30.listeners.filter(function (listener) {\n          return listener !== eventsCallback;\n        });\n      };\n    }\n  }, {\n    key: \"sendRequest\",\n    value: function sendRequest(request, optionsOrOnRequestSent) {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee48() {\n        var options, id, result;\n        return _regeneratorRuntime.wrap(function _callee48$(_context48) {\n          while (1) {\n            switch (_context48.prev = _context48.next) {\n              case 0:\n                // TODO: remove deprecated method\n                options = {};\n\n                if (typeof optionsOrOnRequestSent === 'function') {\n                  options.onRequestSent = optionsOrOnRequestSent;\n                } else {\n                  options.onRequestSent = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.onRequestSent;\n                  options.signal = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.signal;\n                }\n\n                _context48.next = 4;\n                return this.connectionStorage.getNextRpcRequestId();\n\n              case 4:\n                id = _context48.sent.toString();\n                _context48.next = 7;\n                return this.connectionStorage.increaseNextRpcRequestId();\n\n              case 7:\n                logDebug('Send injected-bridge request:', Object.assign(Object.assign({}, request), {\n                  id: id\n                }));\n                result = this.injectedWallet.send(Object.assign(Object.assign({}, request), {\n                  id: id\n                }));\n                result.then(function (response) {\n                  return logDebug('Wallet message received:', response);\n                });\n                (_a = options === null || options === void 0 ? void 0 : options.onRequestSent) === null || _a === void 0 ? void 0 : _a.call(options);\n                return _context48.abrupt(\"return\", result);\n\n              case 12:\n              case \"end\":\n                return _context48.stop();\n            }\n          }\n        }, _callee48, this);\n      }));\n    }\n  }, {\n    key: \"_connect\",\n    value: function _connect(protocolVersion, message) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee49() {\n        var connectEvent, connectEventError;\n        return _regeneratorRuntime.wrap(function _callee49$(_context49) {\n          while (1) {\n            switch (_context49.prev = _context49.next) {\n              case 0:\n                _context49.prev = 0;\n                logDebug(\"Injected Provider connect request: protocolVersion: \".concat(protocolVersion, \", message:\"), message);\n                _context49.next = 4;\n                return this.injectedWallet.connect(protocolVersion, message);\n\n              case 4:\n                connectEvent = _context49.sent;\n                logDebug('Injected Provider connect response:', connectEvent);\n\n                if (!(connectEvent.event === 'connect')) {\n                  _context49.next = 10;\n                  break;\n                }\n\n                _context49.next = 9;\n                return this.updateSession();\n\n              case 9:\n                this.makeSubscriptions();\n\n              case 10:\n                this.listeners.forEach(function (listener) {\n                  return listener(connectEvent);\n                });\n                _context49.next = 18;\n                break;\n\n              case 13:\n                _context49.prev = 13;\n                _context49.t0 = _context49[\"catch\"](0);\n                logDebug('Injected Provider connect error:', _context49.t0);\n                connectEventError = {\n                  event: 'connect_error',\n                  payload: {\n                    code: 0,\n                    message: _context49.t0 === null || _context49.t0 === void 0 ? void 0 : _context49.t0.toString()\n                  }\n                };\n                this.listeners.forEach(function (listener) {\n                  return listener(connectEventError);\n                });\n\n              case 18:\n              case \"end\":\n                return _context49.stop();\n            }\n          }\n        }, _callee49, this, [[0, 13]]);\n      }));\n    }\n  }, {\n    key: \"makeSubscriptions\",\n    value: function makeSubscriptions() {\n      var _this31 = this;\n\n      this.listenSubscriptions = true;\n      this.unsubscribeCallback = this.injectedWallet.listen(function (e) {\n        logDebug('Wallet message received:', e);\n\n        if (_this31.listenSubscriptions) {\n          _this31.listeners.forEach(function (listener) {\n            return listener(e);\n          });\n        }\n\n        if (e.event === 'disconnect') {\n          _this31.disconnect();\n        }\n      });\n    }\n  }, {\n    key: \"updateSession\",\n    value: function updateSession() {\n      return this.connectionStorage.storeConnection({\n        type: 'injected',\n        jsBridgeKey: this.injectedWalletKey,\n        nextRpcRequestId: 0\n      });\n    }\n  }], [{\n    key: \"fromStorage\",\n    value: function fromStorage(storage) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee50() {\n        var bridgeConnectionStorage, connection;\n        return _regeneratorRuntime.wrap(function _callee50$(_context50) {\n          while (1) {\n            switch (_context50.prev = _context50.next) {\n              case 0:\n                bridgeConnectionStorage = new BridgeConnectionStorage(storage);\n                _context50.next = 3;\n                return bridgeConnectionStorage.getInjectedConnection();\n\n              case 3:\n                connection = _context50.sent;\n                return _context50.abrupt(\"return\", new InjectedProvider(storage, connection.jsBridgeKey));\n\n              case 5:\n              case \"end\":\n                return _context50.stop();\n            }\n          }\n        }, _callee50);\n      }));\n    }\n  }, {\n    key: \"isWalletInjected\",\n    value: function isWalletInjected(injectedWalletKey) {\n      return InjectedProvider.isWindowContainsWallet(this.window, injectedWalletKey);\n    }\n  }, {\n    key: \"isInsideWalletBrowser\",\n    value: function isInsideWalletBrowser(injectedWalletKey) {\n      if (InjectedProvider.isWindowContainsWallet(this.window, injectedWalletKey)) {\n        return this.window[injectedWalletKey].tonconnect.isWalletBrowser;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"getCurrentlyInjectedWallets\",\n    value: function getCurrentlyInjectedWallets() {\n      if (!this.window) {\n        return [];\n      }\n\n      var windowKeys = tryGetWindowKeys();\n      var wallets = windowKeys.filter(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            _ = _ref2[0],\n            value = _ref2[1];\n\n        return isJSBridgeWithMetadata(value);\n      });\n      return wallets.map(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            jsBridgeKey = _ref4[0],\n            wallet = _ref4[1];\n\n        return {\n          name: wallet.tonconnect.walletInfo.name,\n          appName: wallet.tonconnect.walletInfo.app_name,\n          aboutUrl: wallet.tonconnect.walletInfo.about_url,\n          imageUrl: wallet.tonconnect.walletInfo.image,\n          tondns: wallet.tonconnect.walletInfo.tondns,\n          jsBridgeKey: jsBridgeKey,\n          injected: true,\n          embedded: wallet.tonconnect.isWalletBrowser,\n          platforms: wallet.tonconnect.walletInfo.platforms\n        };\n      });\n    }\n  }, {\n    key: \"isWindowContainsWallet\",\n    value: function isWindowContainsWallet(window, injectedWalletKey) {\n      return !!window && injectedWalletKey in window && typeof window[injectedWalletKey] === 'object' && 'tonconnect' in window[injectedWalletKey];\n    }\n  }]);\n\n  return InjectedProvider;\n}();\n\nInjectedProvider.window = getWindow();\n/**\n * Default storage to save protocol data, uses `localStorage` if it is available. In Safari's private mode, it uses `InMemoryStorage`. In Node.js, it throws an error.\n */\n\nvar DefaultStorage = /*#__PURE__*/function () {\n  function DefaultStorage() {\n    _classCallCheck(this, DefaultStorage);\n\n    this.localStorage = tryGetLocalStorage();\n  }\n\n  _createClass(DefaultStorage, [{\n    key: \"getItem\",\n    value: function getItem(key) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee51() {\n        return _regeneratorRuntime.wrap(function _callee51$(_context51) {\n          while (1) {\n            switch (_context51.prev = _context51.next) {\n              case 0:\n                return _context51.abrupt(\"return\", this.localStorage.getItem(key));\n\n              case 1:\n              case \"end\":\n                return _context51.stop();\n            }\n          }\n        }, _callee51, this);\n      }));\n    }\n  }, {\n    key: \"removeItem\",\n    value: function removeItem(key) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee52() {\n        return _regeneratorRuntime.wrap(function _callee52$(_context52) {\n          while (1) {\n            switch (_context52.prev = _context52.next) {\n              case 0:\n                this.localStorage.removeItem(key);\n\n              case 1:\n              case \"end\":\n                return _context52.stop();\n            }\n          }\n        }, _callee52, this);\n      }));\n    }\n  }, {\n    key: \"setItem\",\n    value: function setItem(key, value) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee53() {\n        return _regeneratorRuntime.wrap(function _callee53$(_context53) {\n          while (1) {\n            switch (_context53.prev = _context53.next) {\n              case 0:\n                this.localStorage.setItem(key, value);\n\n              case 1:\n              case \"end\":\n                return _context53.stop();\n            }\n          }\n        }, _callee53, this);\n      }));\n    }\n  }]);\n\n  return DefaultStorage;\n}();\n/**\n * Checks if `WalletInfo` is `WalletInfoInjectable` and `WalletInfo` is injected to the current webpage (`walletInfo.injected === true`).\n * @param value WalletInfo to check.\n */\n\n\nfunction isWalletInfoCurrentlyInjected(value) {\n  return isWalletInfoInjectable(value) && value.injected;\n}\n/**\n * Checks if `WalletInfo` is `WalletInfoInjectable` and dApp is opened inside this wallet's browser.\n * @param value WalletInfo to check.\n */\n\n\nfunction isWalletInfoCurrentlyEmbedded(value) {\n  return isWalletInfoCurrentlyInjected(value) && value.embedded;\n}\n/**\n * Checks if `WalletInfo` is `WalletInfoInjected`, but doesn't check if it is injected to the page or not.\n * @param value WalletInfo to check.\n */\n\n\nfunction isWalletInfoInjectable(value) {\n  return 'jsBridgeKey' in value;\n}\n/**\n * Checks if `WalletInfo` is `WalletInfoRemote`.\n * @param value WalletInfo to check.\n */\n\n\nfunction isWalletInfoRemote(value) {\n  return 'bridgeUrl' in value;\n}\n/**\n * @deprecated use `isWalletInfoInjectable` or `isWalletInfoCurrentlyInjected` instead.\n * @param value WalletInfo to check.\n */\n\n\nfunction isWalletInfoInjected(value) {\n  return 'jsBridgeKey' in value;\n}\n\nvar FALLBACK_WALLETS_LIST = [{\n  app_name: 'telegram-wallet',\n  name: 'Wallet',\n  image: 'https://wallet.tg/images/logo-288.png',\n  about_url: 'https://wallet.tg/',\n  universal_url: 'https://t.me/wallet?attach=wallet',\n  bridge: [{\n    type: 'sse',\n    url: 'https://bridge.tonapi.io/bridge'\n  }],\n  platforms: ['ios', 'android', 'macos', 'windows', 'linux']\n}, {\n  app_name: 'tonkeeper',\n  name: 'Tonkeeper',\n  image: 'https://tonkeeper.com/assets/tonconnect-icon.png',\n  tondns: 'tonkeeper.ton',\n  about_url: 'https://tonkeeper.com',\n  universal_url: 'https://app.tonkeeper.com/ton-connect',\n  deepLink: 'tonkeeper-tc://',\n  bridge: [{\n    type: 'sse',\n    url: 'https://bridge.tonapi.io/bridge'\n  }, {\n    type: 'js',\n    key: 'tonkeeper'\n  }],\n  platforms: ['ios', 'android', 'chrome', 'firefox', 'macos']\n}, {\n  app_name: 'mytonwallet',\n  name: 'MyTonWallet',\n  image: 'https://mytonwallet.io/icon-256.png',\n  about_url: 'https://mytonwallet.io',\n  universal_url: 'https://connect.mytonwallet.org',\n  bridge: [{\n    type: 'js',\n    key: 'mytonwallet'\n  }, {\n    type: 'sse',\n    url: 'https://tonconnectbridge.mytonwallet.org/bridge/'\n  }],\n  platforms: ['chrome', 'windows', 'macos', 'linux', 'ios', 'android', 'firefox']\n}, {\n  app_name: 'openmask',\n  name: 'OpenMask',\n  image: 'https://raw.githubusercontent.com/OpenProduct/openmask-extension/main/public/openmask-logo-288.png',\n  about_url: 'https://www.openmask.app/',\n  bridge: [{\n    type: 'js',\n    key: 'openmask'\n  }],\n  platforms: ['chrome']\n}, {\n  app_name: 'tonhub',\n  name: 'Tonhub',\n  image: 'https://tonhub.com/tonconnect_logo.png',\n  about_url: 'https://tonhub.com',\n  universal_url: 'https://tonhub.com/ton-connect',\n  bridge: [{\n    type: 'js',\n    key: 'tonhub'\n  }, {\n    type: 'sse',\n    url: 'https://connect.tonhubapi.com/tonconnect'\n  }],\n  platforms: ['ios', 'android']\n}, {\n  app_name: 'dewallet',\n  name: 'DeWallet',\n  image: 'https://app.delabwallet.com/logo_black.png',\n  about_url: 'https://delabwallet.com',\n  bridge: [{\n    type: 'js',\n    key: 'dewallet'\n  }],\n  platforms: ['chrome']\n}, {\n  app_name: 'xtonwallet',\n  name: 'XTONWallet',\n  image: 'https://xtonwallet.com/assets/img/icon-256-back.png',\n  about_url: 'https://xtonwallet.com',\n  bridge: [{\n    type: 'js',\n    key: 'xtonwallet'\n  }],\n  platforms: ['chrome', 'firefox']\n}, {\n  app_name: 'tonwallet',\n  name: 'TON Wallet',\n  image: 'https://wallet.ton.org/assets/ui/qr-logo.png',\n  about_url: 'https://chrome.google.com/webstore/detail/ton-wallet/nphplpgoakhhjchkkhmiggakijnkhfnd',\n  bridge: [{\n    type: 'js',\n    key: 'tonwallet'\n  }],\n  platforms: ['chrome']\n}];\n\nvar WalletsListManager = /*#__PURE__*/function () {\n  function WalletsListManager(options) {\n    _classCallCheck(this, WalletsListManager);\n\n    this.walletsListCache = null;\n    this.walletsListCacheCreationTimestamp = null;\n    this.walletsListSource = 'https://raw.githubusercontent.com/ton-blockchain/wallets-list/main/wallets-v2.json';\n\n    if (options === null || options === void 0 ? void 0 : options.walletsListSource) {\n      this.walletsListSource = options.walletsListSource;\n    }\n\n    if (options === null || options === void 0 ? void 0 : options.cacheTTLMs) {\n      this.cacheTTLMs = options.cacheTTLMs;\n    }\n  }\n\n  _createClass(WalletsListManager, [{\n    key: \"getWallets\",\n    value: function getWallets() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee54() {\n        var _this32 = this;\n\n        return _regeneratorRuntime.wrap(function _callee54$(_context54) {\n          while (1) {\n            switch (_context54.prev = _context54.next) {\n              case 0:\n                if (this.cacheTTLMs && this.walletsListCacheCreationTimestamp && Date.now() > this.walletsListCacheCreationTimestamp + this.cacheTTLMs) {\n                  this.walletsListCache = null;\n                }\n\n                if (!this.walletsListCache) {\n                  this.walletsListCache = this.fetchWalletsList();\n                  this.walletsListCache.then(function () {\n                    _this32.walletsListCacheCreationTimestamp = Date.now();\n                  }).catch(function () {\n                    _this32.walletsListCache = null;\n                    _this32.walletsListCacheCreationTimestamp = null;\n                  });\n                }\n\n                return _context54.abrupt(\"return\", this.walletsListCache);\n\n              case 3:\n              case \"end\":\n                return _context54.stop();\n            }\n          }\n        }, _callee54, this);\n      }));\n    }\n  }, {\n    key: \"getEmbeddedWallet\",\n    value: function getEmbeddedWallet() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee55() {\n        var walletsList, embeddedWallets;\n        return _regeneratorRuntime.wrap(function _callee55$(_context55) {\n          while (1) {\n            switch (_context55.prev = _context55.next) {\n              case 0:\n                _context55.next = 2;\n                return this.getWallets();\n\n              case 2:\n                walletsList = _context55.sent;\n                embeddedWallets = walletsList.filter(isWalletInfoCurrentlyEmbedded);\n\n                if (!(embeddedWallets.length !== 1)) {\n                  _context55.next = 6;\n                  break;\n                }\n\n                return _context55.abrupt(\"return\", null);\n\n              case 6:\n                return _context55.abrupt(\"return\", embeddedWallets[0]);\n\n              case 7:\n              case \"end\":\n                return _context55.stop();\n            }\n          }\n        }, _callee55, this);\n      }));\n    }\n  }, {\n    key: \"fetchWalletsList\",\n    value: function fetchWalletsList() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee56() {\n        var _this33 = this;\n\n        var walletsList, walletsResponse, wrongFormatWallets, currentlyInjectedWallets;\n        return _regeneratorRuntime.wrap(function _callee56$(_context56) {\n          while (1) {\n            switch (_context56.prev = _context56.next) {\n              case 0:\n                walletsList = [];\n                _context56.prev = 1;\n                _context56.next = 4;\n                return fetch(this.walletsListSource);\n\n              case 4:\n                walletsResponse = _context56.sent;\n                _context56.next = 7;\n                return walletsResponse.json();\n\n              case 7:\n                walletsList = _context56.sent;\n\n                if (Array.isArray(walletsList)) {\n                  _context56.next = 10;\n                  break;\n                }\n\n                throw new FetchWalletsError('Wrong wallets list format, wallets list must be an array.');\n\n              case 10:\n                wrongFormatWallets = walletsList.filter(function (wallet) {\n                  return !_this33.isCorrectWalletConfigDTO(wallet);\n                });\n\n                if (wrongFormatWallets.length) {\n                  logError(\"Wallet(s) \".concat(wrongFormatWallets.map(function (wallet) {\n                    return wallet.name;\n                  }).join(', '), \" config format is wrong. They were removed from the wallets list.\"));\n                  walletsList = walletsList.filter(function (wallet) {\n                    return _this33.isCorrectWalletConfigDTO(wallet);\n                  });\n                }\n\n                _context56.next = 18;\n                break;\n\n              case 14:\n                _context56.prev = 14;\n                _context56.t0 = _context56[\"catch\"](1);\n                logError(_context56.t0);\n                walletsList = FALLBACK_WALLETS_LIST;\n\n              case 18:\n                currentlyInjectedWallets = [];\n\n                try {\n                  currentlyInjectedWallets = InjectedProvider.getCurrentlyInjectedWallets();\n                } catch (e) {\n                  logError(e);\n                }\n\n                return _context56.abrupt(\"return\", this.mergeWalletsLists(this.walletConfigDTOListToWalletConfigList(walletsList), currentlyInjectedWallets));\n\n              case 21:\n              case \"end\":\n                return _context56.stop();\n            }\n          }\n        }, _callee56, this, [[1, 14]]);\n      }));\n    }\n  }, {\n    key: \"walletConfigDTOListToWalletConfigList\",\n    value: function walletConfigDTOListToWalletConfigList(walletConfigDTO) {\n      return walletConfigDTO.map(function (walletConfigDTO) {\n        var walletConfigBase = {\n          name: walletConfigDTO.name,\n          appName: walletConfigDTO.app_name,\n          imageUrl: walletConfigDTO.image,\n          aboutUrl: walletConfigDTO.about_url,\n          tondns: walletConfigDTO.tondns,\n          platforms: walletConfigDTO.platforms\n        };\n        var walletConfig = walletConfigBase;\n        walletConfigDTO.bridge.forEach(function (bridge) {\n          if (bridge.type === 'sse') {\n            walletConfig.bridgeUrl = bridge.url;\n            walletConfig.universalLink = walletConfigDTO.universal_url;\n            walletConfig.deepLink = walletConfigDTO.deepLink;\n          }\n\n          if (bridge.type === 'js') {\n            var jsBridgeKey = bridge.key;\n            walletConfig.jsBridgeKey = jsBridgeKey;\n            walletConfig.injected = InjectedProvider.isWalletInjected(jsBridgeKey);\n            walletConfig.embedded = InjectedProvider.isInsideWalletBrowser(jsBridgeKey);\n          }\n        });\n        return walletConfig;\n      });\n    }\n  }, {\n    key: \"mergeWalletsLists\",\n    value: function mergeWalletsLists(list1, list2) {\n      var names = new Set(list1.concat(list2).map(function (item) {\n        return item.name;\n      }));\n      return _toConsumableArray(names.values()).map(function (name) {\n        var list1Item = list1.find(function (item) {\n          return item.name === name;\n        });\n        var list2Item = list2.find(function (item) {\n          return item.name === name;\n        });\n        return Object.assign(Object.assign({}, list1Item && Object.assign({}, list1Item)), list2Item && Object.assign({}, list2Item));\n      });\n    } // eslint-disable-next-line complexity\n\n  }, {\n    key: \"isCorrectWalletConfigDTO\",\n    value: function isCorrectWalletConfigDTO(value) {\n      if (!value || !(typeof value === 'object')) {\n        return false;\n      }\n\n      var containsName = ('name' in value);\n      var containsAppName = ('app_name' in value);\n      var containsImage = ('image' in value);\n      var containsAbout = ('about_url' in value);\n      var containsPlatforms = ('platforms' in value);\n\n      if (!containsName || !containsImage || !containsAbout || !containsPlatforms || !containsAppName) {\n        return false;\n      }\n\n      if (!value.platforms || !Array.isArray(value.platforms) || !value.platforms.length) {\n        return false;\n      }\n\n      if (!('bridge' in value) || !Array.isArray(value.bridge) || !value.bridge.length) {\n        return false;\n      }\n\n      var bridge = value.bridge;\n\n      if (bridge.some(function (item) {\n        return !item || typeof item !== 'object' || !('type' in item);\n      })) {\n        return false;\n      }\n\n      var sseBridge = bridge.find(function (item) {\n        return item.type === 'sse';\n      });\n\n      if (sseBridge) {\n        if (!('url' in sseBridge) || !sseBridge.url || !value.universal_url) {\n          return false;\n        }\n      }\n\n      var jsBridge = bridge.find(function (item) {\n        return item.type === 'js';\n      });\n\n      if (jsBridge) {\n        if (!('key' in jsBridge) || !jsBridge.key) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }]);\n\n  return WalletsListManager;\n}();\n/**\n * Thrown when wallet doesn't support requested feature method.\n */\n\n\nvar WalletNotSupportFeatureError = /*#__PURE__*/function (_TonConnectError15) {\n  _inherits(WalletNotSupportFeatureError, _TonConnectError15);\n\n  var _super17 = _createSuper(WalletNotSupportFeatureError);\n\n  function WalletNotSupportFeatureError() {\n    var _this34;\n\n    _classCallCheck(this, WalletNotSupportFeatureError);\n\n    for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {\n      args[_key19] = arguments[_key19];\n    }\n\n    _this34 = _super17.call.apply(_super17, [this].concat(args));\n    Object.setPrototypeOf(_assertThisInitialized(_this34), WalletNotSupportFeatureError.prototype);\n    return _this34;\n  }\n\n  _createClass(WalletNotSupportFeatureError, [{\n    key: \"info\",\n    get: function get() {\n      return \"Wallet doesn't support requested feature method.\";\n    }\n  }]);\n\n  return WalletNotSupportFeatureError;\n}(TonConnectError);\n\nfunction checkSendTransactionSupport(features, options) {\n  var supportsDeprecatedSendTransactionFeature = features.includes('SendTransaction');\n  var sendTransactionFeature = features.find(function (feature) {\n    return feature && typeof feature === 'object' && feature.name === 'SendTransaction';\n  });\n\n  if (!supportsDeprecatedSendTransactionFeature && !sendTransactionFeature) {\n    throw new WalletNotSupportFeatureError(\"Wallet doesn't support SendTransaction feature.\");\n  }\n\n  if (sendTransactionFeature && sendTransactionFeature.maxMessages !== undefined) {\n    if (sendTransactionFeature.maxMessages < options.requiredMessagesNumber) {\n      throw new WalletNotSupportFeatureError(\"Wallet is not able to handle such SendTransaction request. Max support messages number is \".concat(sendTransactionFeature.maxMessages, \", but \").concat(options.requiredMessagesNumber, \" is required.\"));\n    }\n\n    return;\n  }\n\n  logWarning(\"Connected wallet didn't provide information about max allowed messages in the SendTransaction request. Request may be rejected by the wallet.\");\n}\n/**\n * Create a request version event.\n */\n\n\nfunction createRequestVersionEvent() {\n  return {\n    type: 'request-version'\n  };\n}\n/**\n * Create a response version event.\n * @param version\n */\n\n\nfunction createResponseVersionEvent(version) {\n  return {\n    type: 'response-version',\n    version: version\n  };\n}\n/**\n * Create a version info.\n * @param version\n */\n\n\nfunction createVersionInfo(version) {\n  return {\n    ton_connect_sdk_lib: version.ton_connect_sdk_lib,\n    ton_connect_ui_lib: version.ton_connect_ui_lib\n  };\n}\n\nfunction createConnectionInfo(version, wallet) {\n  var _a, _b, _c, _d, _e, _f, _g, _h;\n\n  var isTonProof = ((_a = wallet === null || wallet === void 0 ? void 0 : wallet.connectItems) === null || _a === void 0 ? void 0 : _a.tonProof) && 'proof' in wallet.connectItems.tonProof;\n  var authType = isTonProof ? 'ton_proof' : 'ton_addr';\n  return {\n    wallet_address: (_c = (_b = wallet === null || wallet === void 0 ? void 0 : wallet.account) === null || _b === void 0 ? void 0 : _b.address) !== null && _c !== void 0 ? _c : null,\n    wallet_type: (_d = wallet === null || wallet === void 0 ? void 0 : wallet.device.appName) !== null && _d !== void 0 ? _d : null,\n    wallet_version: (_e = wallet === null || wallet === void 0 ? void 0 : wallet.device.appVersion) !== null && _e !== void 0 ? _e : null,\n    auth_type: authType,\n    custom_data: Object.assign({\n      chain_id: (_g = (_f = wallet === null || wallet === void 0 ? void 0 : wallet.account) === null || _f === void 0 ? void 0 : _f.chain) !== null && _g !== void 0 ? _g : null,\n      provider: (_h = wallet === null || wallet === void 0 ? void 0 : wallet.provider) !== null && _h !== void 0 ? _h : null\n    }, createVersionInfo(version))\n  };\n}\n/**\n * Create a connection init event.\n */\n\n\nfunction createConnectionStartedEvent(version) {\n  return {\n    type: 'connection-started',\n    custom_data: createVersionInfo(version)\n  };\n}\n/**\n * Create a connection completed event.\n * @param version\n * @param wallet\n */\n\n\nfunction createConnectionCompletedEvent(version, wallet) {\n  return Object.assign({\n    type: 'connection-completed',\n    is_success: true\n  }, createConnectionInfo(version, wallet));\n}\n/**\n * Create a connection error event.\n * @param version\n * @param error_message\n * @param errorCode\n */\n\n\nfunction createConnectionErrorEvent(version, error_message, errorCode) {\n  return {\n    type: 'connection-error',\n    is_success: false,\n    error_message: error_message,\n    error_code: errorCode !== null && errorCode !== void 0 ? errorCode : null,\n    custom_data: createVersionInfo(version)\n  };\n}\n/**\n * Create a connection restoring started event.\n */\n\n\nfunction createConnectionRestoringStartedEvent(version) {\n  return {\n    type: 'connection-restoring-started',\n    custom_data: createVersionInfo(version)\n  };\n}\n/**\n * Create a connection restoring completed event.\n * @param version\n * @param wallet\n */\n\n\nfunction createConnectionRestoringCompletedEvent(version, wallet) {\n  return Object.assign({\n    type: 'connection-restoring-completed',\n    is_success: true\n  }, createConnectionInfo(version, wallet));\n}\n/**\n * Create a connection restoring error event.\n * @param version\n * @param errorMessage\n */\n\n\nfunction createConnectionRestoringErrorEvent(version, errorMessage) {\n  return {\n    type: 'connection-restoring-error',\n    is_success: false,\n    error_message: errorMessage,\n    custom_data: createVersionInfo(version)\n  };\n}\n\nfunction createTransactionInfo(wallet, transaction) {\n  var _a, _b, _c, _d;\n\n  return {\n    valid_until: (_a = String(transaction.validUntil)) !== null && _a !== void 0 ? _a : null,\n    from: (_d = (_b = transaction.from) !== null && _b !== void 0 ? _b : (_c = wallet === null || wallet === void 0 ? void 0 : wallet.account) === null || _c === void 0 ? void 0 : _c.address) !== null && _d !== void 0 ? _d : null,\n    messages: transaction.messages.map(function (message) {\n      var _a, _b;\n\n      return {\n        address: (_a = message.address) !== null && _a !== void 0 ? _a : null,\n        amount: (_b = message.amount) !== null && _b !== void 0 ? _b : null\n      };\n    })\n  };\n}\n/**\n * Create a transaction init event.\n * @param version\n * @param wallet\n * @param transaction\n */\n\n\nfunction createTransactionSentForSignatureEvent(version, wallet, transaction) {\n  return Object.assign(Object.assign({\n    type: 'transaction-sent-for-signature'\n  }, createConnectionInfo(version, wallet)), createTransactionInfo(wallet, transaction));\n}\n/**\n * Create a transaction signed event.\n * @param version\n * @param wallet\n * @param transaction\n * @param signedTransaction\n */\n\n\nfunction createTransactionSignedEvent(version, wallet, transaction, signedTransaction) {\n  return Object.assign(Object.assign({\n    type: 'transaction-signed',\n    is_success: true,\n    signed_transaction: signedTransaction.boc\n  }, createConnectionInfo(version, wallet)), createTransactionInfo(wallet, transaction));\n}\n/**\n * Create a transaction error event.\n * @param version\n * @param wallet\n * @param transaction\n * @param errorMessage\n * @param errorCode\n */\n\n\nfunction createTransactionSigningFailedEvent(version, wallet, transaction, errorMessage, errorCode) {\n  return Object.assign(Object.assign({\n    type: 'transaction-signing-failed',\n    is_success: false,\n    error_message: errorMessage,\n    error_code: errorCode !== null && errorCode !== void 0 ? errorCode : null\n  }, createConnectionInfo(version, wallet)), createTransactionInfo(wallet, transaction));\n}\n/**\n * Create a disconnect event.\n * @param version\n * @param wallet\n * @param scope\n * @returns\n */\n\n\nfunction createDisconnectionEvent(version, wallet, scope) {\n  return Object.assign({\n    type: 'disconnection',\n    scope: scope\n  }, createConnectionInfo(version, wallet));\n}\n/**\n * A concrete implementation of EventDispatcher that dispatches events to the browser window.\n */\n\n\nvar BrowserEventDispatcher = /*#__PURE__*/function () {\n  function BrowserEventDispatcher() {\n    _classCallCheck(this, BrowserEventDispatcher);\n\n    /**\n     * The window object, possibly undefined in a server environment.\n     * @private\n     */\n    this.window = getWindow();\n  }\n  /**\n   * Dispatches an event with the given name and details to the browser window.\n   * @param eventName - The name of the event to dispatch.\n   * @param eventDetails - The details of the event to dispatch.\n   * @returns A promise that resolves when the event has been dispatched.\n   */\n\n\n  _createClass(BrowserEventDispatcher, [{\n    key: \"dispatchEvent\",\n    value: function dispatchEvent(eventName, eventDetails) {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee57() {\n        var event;\n        return _regeneratorRuntime.wrap(function _callee57$(_context57) {\n          while (1) {\n            switch (_context57.prev = _context57.next) {\n              case 0:\n                event = new CustomEvent(eventName, {\n                  detail: eventDetails\n                });\n                (_a = this.window) === null || _a === void 0 ? void 0 : _a.dispatchEvent(event);\n\n              case 2:\n              case \"end\":\n                return _context57.stop();\n            }\n          }\n        }, _callee57, this);\n      }));\n    }\n    /**\n     * Adds an event listener to the browser window.\n     * @param eventName - The name of the event to listen for.\n     * @param listener - The listener to add.\n     * @param options - The options for the listener.\n     * @returns A function that removes the listener.\n     */\n\n  }, {\n    key: \"addEventListener\",\n    value: function addEventListener(eventName, listener, options) {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee58() {\n        var _this35 = this;\n\n        return _regeneratorRuntime.wrap(function _callee58$(_context58) {\n          while (1) {\n            switch (_context58.prev = _context58.next) {\n              case 0:\n                (_a = this.window) === null || _a === void 0 ? void 0 : _a.addEventListener(eventName, listener, options);\n                return _context58.abrupt(\"return\", function () {\n                  var _a;\n\n                  return (_a = _this35.window) === null || _a === void 0 ? void 0 : _a.removeEventListener(eventName, listener);\n                });\n\n              case 2:\n              case \"end\":\n                return _context58.stop();\n            }\n          }\n        }, _callee58, this);\n      }));\n    }\n  }]);\n\n  return BrowserEventDispatcher;\n}();\n/**\n * Tracker for TonConnect user actions, such as transaction signing, connection, etc.\n *\n * List of events:\n *  * `connection-started`: when a user starts connecting a wallet.\n *  * `connection-completed`: when a user successfully connected a wallet.\n *  * `connection-error`: when a user cancels a connection or there is an error during the connection process.\n *  * `connection-restoring-started`: when the dApp starts restoring a connection.\n *  * `connection-restoring-completed`: when the dApp successfully restores a connection.\n *  * `connection-restoring-error`: when the dApp fails to restore a connection.\n *  * `disconnection`: when a user starts disconnecting a wallet.\n *  * `transaction-sent-for-signature`: when a user sends a transaction for signature.\n *  * `transaction-signed`: when a user successfully signs a transaction.\n *  * `transaction-signing-failed`: when a user cancels transaction signing or there is an error during the signing process.\n *\n * If you want to track user actions, you can subscribe to the window events with prefix `ton-connect-`:\n *\n * @example\n * window.addEventListener('ton-connect-transaction-sent-for-signature', (event) => {\n *    console.log('Transaction init', event.detail);\n * });\n *\n * @internal\n */\n\n\nvar TonConnectTracker = /*#__PURE__*/function () {\n  function TonConnectTracker(options) {\n    _classCallCheck(this, TonConnectTracker);\n\n    var _a;\n    /**\n     * Event prefix for user actions.\n     * @private\n     */\n\n\n    this.eventPrefix = 'ton-connect-';\n    /**\n     * TonConnect UI version.\n     */\n\n    this.tonConnectUiVersion = null;\n    this.eventDispatcher = (_a = options === null || options === void 0 ? void 0 : options.eventDispatcher) !== null && _a !== void 0 ? _a : new BrowserEventDispatcher();\n    this.tonConnectSdkVersion = options.tonConnectSdkVersion;\n    this.init().catch();\n  }\n  /**\n   * Version of the library.\n   */\n\n\n  _createClass(TonConnectTracker, [{\n    key: \"version\",\n    get: function get() {\n      return createVersionInfo({\n        ton_connect_sdk_lib: this.tonConnectSdkVersion,\n        ton_connect_ui_lib: this.tonConnectUiVersion\n      });\n    }\n    /**\n     * Called once when the tracker is created and request version other libraries.\n     */\n\n  }, {\n    key: \"init\",\n    value: function init() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee59() {\n        return _regeneratorRuntime.wrap(function _callee59$(_context59) {\n          while (1) {\n            switch (_context59.prev = _context59.next) {\n              case 0:\n                _context59.prev = 0;\n                _context59.next = 3;\n                return this.setRequestVersionHandler();\n\n              case 3:\n                _context59.next = 5;\n                return this.requestTonConnectUiVersion();\n\n              case 5:\n                this.tonConnectUiVersion = _context59.sent;\n                _context59.next = 10;\n                break;\n\n              case 8:\n                _context59.prev = 8;\n                _context59.t0 = _context59[\"catch\"](0);\n\n              case 10:\n              case \"end\":\n                return _context59.stop();\n            }\n          }\n        }, _callee59, this, [[0, 8]]);\n      }));\n    }\n    /**\n     * Set request version handler.\n     * @private\n     */\n\n  }, {\n    key: \"setRequestVersionHandler\",\n    value: function setRequestVersionHandler() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee61() {\n        var _this36 = this;\n\n        return _regeneratorRuntime.wrap(function _callee61$(_context61) {\n          while (1) {\n            switch (_context61.prev = _context61.next) {\n              case 0:\n                _context61.next = 2;\n                return this.eventDispatcher.addEventListener('ton-connect-request-version', function () {\n                  return __awaiter(_this36, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee60() {\n                    return _regeneratorRuntime.wrap(function _callee60$(_context60) {\n                      while (1) {\n                        switch (_context60.prev = _context60.next) {\n                          case 0:\n                            _context60.next = 2;\n                            return this.eventDispatcher.dispatchEvent('ton-connect-response-version', createResponseVersionEvent(this.tonConnectSdkVersion));\n\n                          case 2:\n                          case \"end\":\n                            return _context60.stop();\n                        }\n                      }\n                    }, _callee60, this);\n                  }));\n                });\n\n              case 2:\n              case \"end\":\n                return _context61.stop();\n            }\n          }\n        }, _callee61, this);\n      }));\n    }\n    /**\n     * Request TonConnect UI version.\n     * @private\n     */\n\n  }, {\n    key: \"requestTonConnectUiVersion\",\n    value: function requestTonConnectUiVersion() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee63() {\n        var _this37 = this;\n\n        return _regeneratorRuntime.wrap(function _callee63$(_context63) {\n          while (1) {\n            switch (_context63.prev = _context63.next) {\n              case 0:\n                return _context63.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  return __awaiter(_this37, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee62() {\n                    return _regeneratorRuntime.wrap(function _callee62$(_context62) {\n                      while (1) {\n                        switch (_context62.prev = _context62.next) {\n                          case 0:\n                            _context62.prev = 0;\n                            _context62.next = 3;\n                            return this.eventDispatcher.addEventListener('ton-connect-ui-response-version', function (event) {\n                              resolve(event.detail.version);\n                            }, {\n                              once: true\n                            });\n\n                          case 3:\n                            _context62.next = 5;\n                            return this.eventDispatcher.dispatchEvent('ton-connect-ui-request-version', createRequestVersionEvent());\n\n                          case 5:\n                            _context62.next = 10;\n                            break;\n\n                          case 7:\n                            _context62.prev = 7;\n                            _context62.t0 = _context62[\"catch\"](0);\n                            reject(_context62.t0);\n\n                          case 10:\n                          case \"end\":\n                            return _context62.stop();\n                        }\n                      }\n                    }, _callee62, this, [[0, 7]]);\n                  }));\n                }));\n\n              case 1:\n              case \"end\":\n                return _context63.stop();\n            }\n          }\n        }, _callee63);\n      }));\n    }\n    /**\n     * Emit user action event to the window.\n     * @param eventDetails\n     * @private\n     */\n\n  }, {\n    key: \"dispatchUserActionEvent\",\n    value: function dispatchUserActionEvent(eventDetails) {\n      try {\n        this.eventDispatcher.dispatchEvent(\"\".concat(this.eventPrefix).concat(eventDetails.type), eventDetails).catch();\n      } catch (e) {}\n    }\n    /**\n     * Track connection init event.\n     * @param args\n     */\n\n  }, {\n    key: \"trackConnectionStarted\",\n    value: function trackConnectionStarted() {\n      try {\n        for (var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {\n          args[_key20] = arguments[_key20];\n        }\n\n        var event = createConnectionStartedEvent.apply(void 0, [this.version].concat(args));\n        this.dispatchUserActionEvent(event);\n      } catch (e) {}\n    }\n    /**\n     * Track connection success event.\n     * @param args\n     */\n\n  }, {\n    key: \"trackConnectionCompleted\",\n    value: function trackConnectionCompleted() {\n      try {\n        for (var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {\n          args[_key21] = arguments[_key21];\n        }\n\n        var event = createConnectionCompletedEvent.apply(void 0, [this.version].concat(args));\n        this.dispatchUserActionEvent(event);\n      } catch (e) {}\n    }\n    /**\n     * Track connection error event.\n     * @param args\n     */\n\n  }, {\n    key: \"trackConnectionError\",\n    value: function trackConnectionError() {\n      try {\n        for (var _len22 = arguments.length, args = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {\n          args[_key22] = arguments[_key22];\n        }\n\n        var event = createConnectionErrorEvent.apply(void 0, [this.version].concat(args));\n        this.dispatchUserActionEvent(event);\n      } catch (e) {}\n    }\n    /**\n     * Track connection restoring init event.\n     * @param args\n     */\n\n  }, {\n    key: \"trackConnectionRestoringStarted\",\n    value: function trackConnectionRestoringStarted() {\n      try {\n        for (var _len23 = arguments.length, args = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++) {\n          args[_key23] = arguments[_key23];\n        }\n\n        var event = createConnectionRestoringStartedEvent.apply(void 0, [this.version].concat(args));\n        this.dispatchUserActionEvent(event);\n      } catch (e) {}\n    }\n    /**\n     * Track connection restoring success event.\n     * @param args\n     */\n\n  }, {\n    key: \"trackConnectionRestoringCompleted\",\n    value: function trackConnectionRestoringCompleted() {\n      try {\n        for (var _len24 = arguments.length, args = new Array(_len24), _key24 = 0; _key24 < _len24; _key24++) {\n          args[_key24] = arguments[_key24];\n        }\n\n        var event = createConnectionRestoringCompletedEvent.apply(void 0, [this.version].concat(args));\n        this.dispatchUserActionEvent(event);\n      } catch (e) {}\n    }\n    /**\n     * Track connection restoring error event.\n     * @param args\n     */\n\n  }, {\n    key: \"trackConnectionRestoringError\",\n    value: function trackConnectionRestoringError() {\n      try {\n        for (var _len25 = arguments.length, args = new Array(_len25), _key25 = 0; _key25 < _len25; _key25++) {\n          args[_key25] = arguments[_key25];\n        }\n\n        var event = createConnectionRestoringErrorEvent.apply(void 0, [this.version].concat(args));\n        this.dispatchUserActionEvent(event);\n      } catch (e) {}\n    }\n    /**\n     * Track disconnect event.\n     * @param args\n     */\n\n  }, {\n    key: \"trackDisconnection\",\n    value: function trackDisconnection() {\n      try {\n        for (var _len26 = arguments.length, args = new Array(_len26), _key26 = 0; _key26 < _len26; _key26++) {\n          args[_key26] = arguments[_key26];\n        }\n\n        var event = createDisconnectionEvent.apply(void 0, [this.version].concat(args));\n        this.dispatchUserActionEvent(event);\n      } catch (e) {}\n    }\n    /**\n     * Track transaction init event.\n     * @param args\n     */\n\n  }, {\n    key: \"trackTransactionSentForSignature\",\n    value: function trackTransactionSentForSignature() {\n      try {\n        for (var _len27 = arguments.length, args = new Array(_len27), _key27 = 0; _key27 < _len27; _key27++) {\n          args[_key27] = arguments[_key27];\n        }\n\n        var event = createTransactionSentForSignatureEvent.apply(void 0, [this.version].concat(args));\n        this.dispatchUserActionEvent(event);\n      } catch (e) {}\n    }\n    /**\n     * Track transaction signed event.\n     * @param args\n     */\n\n  }, {\n    key: \"trackTransactionSigned\",\n    value: function trackTransactionSigned() {\n      try {\n        for (var _len28 = arguments.length, args = new Array(_len28), _key28 = 0; _key28 < _len28; _key28++) {\n          args[_key28] = arguments[_key28];\n        }\n\n        var event = createTransactionSignedEvent.apply(void 0, [this.version].concat(args));\n        this.dispatchUserActionEvent(event);\n      } catch (e) {}\n    }\n    /**\n     * Track transaction error event.\n     * @param args\n     */\n\n  }, {\n    key: \"trackTransactionSigningFailed\",\n    value: function trackTransactionSigningFailed() {\n      try {\n        for (var _len29 = arguments.length, args = new Array(_len29), _key29 = 0; _key29 < _len29; _key29++) {\n          args[_key29] = arguments[_key29];\n        }\n\n        var event = createTransactionSigningFailedEvent.apply(void 0, [this.version].concat(args));\n        this.dispatchUserActionEvent(event);\n      } catch (e) {}\n    }\n  }]);\n\n  return TonConnectTracker;\n}();\n\nvar tonConnectSdkVersion = \"3.0.3\";\n\nvar TonConnect = /*#__PURE__*/function () {\n  function TonConnect(options) {\n    _classCallCheck(this, TonConnect);\n\n    this.walletsList = new WalletsListManager();\n    this._wallet = null;\n    this.provider = null;\n    this.statusChangeSubscriptions = [];\n    this.statusChangeErrorSubscriptions = [];\n    this.dappSettings = {\n      manifestUrl: (options === null || options === void 0 ? void 0 : options.manifestUrl) || getWebPageManifest(),\n      storage: (options === null || options === void 0 ? void 0 : options.storage) || new DefaultStorage()\n    };\n    this.walletsList = new WalletsListManager({\n      walletsListSource: options === null || options === void 0 ? void 0 : options.walletsListSource,\n      cacheTTLMs: options === null || options === void 0 ? void 0 : options.walletsListCacheTTLMs\n    });\n    this.tracker = new TonConnectTracker({\n      eventDispatcher: options === null || options === void 0 ? void 0 : options.eventDispatcher,\n      tonConnectSdkVersion: tonConnectSdkVersion\n    });\n\n    if (!this.dappSettings.manifestUrl) {\n      throw new DappMetadataError('Dapp tonconnect-manifest.json must be specified if window.location.origin is undefined. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest');\n    }\n\n    this.bridgeConnectionStorage = new BridgeConnectionStorage(this.dappSettings.storage);\n\n    if (!(options === null || options === void 0 ? void 0 : options.disableAutoPauseConnection)) {\n      this.addWindowFocusAndBlurSubscriptions();\n    }\n  }\n  /**\n   * Returns available wallets list.\n   */\n\n\n  _createClass(TonConnect, [{\n    key: \"connected\",\n    get:\n    /**\n     * Shows if the wallet is connected right now.\n     */\n    function get() {\n      return this._wallet !== null;\n    }\n    /**\n     * Current connected account or null if no account is connected.\n     */\n\n  }, {\n    key: \"account\",\n    get: function get() {\n      var _a;\n\n      return ((_a = this._wallet) === null || _a === void 0 ? void 0 : _a.account) || null;\n    }\n    /**\n     * Current connected wallet or null if no account is connected.\n     */\n\n  }, {\n    key: \"wallet\",\n    get: function get() {\n      return this._wallet;\n    },\n    set: function set(value) {\n      var _this38 = this;\n\n      this._wallet = value;\n      this.statusChangeSubscriptions.forEach(function (callback) {\n        return callback(_this38._wallet);\n      });\n    }\n    /**\n     * Returns available wallets list.\n     */\n\n  }, {\n    key: \"getWallets\",\n    value: function getWallets() {\n      return this.walletsList.getWallets();\n    }\n    /**\n     * Allows to subscribe to connection status changes and handle connection errors.\n     * @param callback will be called after connections status changes with actual wallet or null.\n     * @param errorsHandler (optional) will be called with some instance of TonConnectError when connect error is received.\n     * @returns unsubscribe callback.\n     */\n\n  }, {\n    key: \"onStatusChange\",\n    value: function onStatusChange(callback, errorsHandler) {\n      var _this39 = this;\n\n      this.statusChangeSubscriptions.push(callback);\n\n      if (errorsHandler) {\n        this.statusChangeErrorSubscriptions.push(errorsHandler);\n      }\n\n      return function () {\n        _this39.statusChangeSubscriptions = _this39.statusChangeSubscriptions.filter(function (item) {\n          return item !== callback;\n        });\n\n        if (errorsHandler) {\n          _this39.statusChangeErrorSubscriptions = _this39.statusChangeErrorSubscriptions.filter(function (item) {\n            return item !== errorsHandler;\n          });\n        }\n      };\n    }\n  }, {\n    key: \"connect\",\n    value: function connect(wallet, requestOrOptions) {\n      var _this40 = this;\n\n      var _a, _b; // TODO: remove deprecated method\n\n\n      var options = {};\n\n      if (typeof requestOrOptions === 'object' && 'tonProof' in requestOrOptions) {\n        options.request = requestOrOptions;\n      }\n\n      if (typeof requestOrOptions === 'object' && ('openingDeadlineMS' in requestOrOptions || 'signal' in requestOrOptions || 'request' in requestOrOptions)) {\n        options.request = requestOrOptions === null || requestOrOptions === void 0 ? void 0 : requestOrOptions.request;\n        options.openingDeadlineMS = requestOrOptions === null || requestOrOptions === void 0 ? void 0 : requestOrOptions.openingDeadlineMS;\n        options.signal = requestOrOptions === null || requestOrOptions === void 0 ? void 0 : requestOrOptions.signal;\n      }\n\n      if (this.connected) {\n        throw new WalletAlreadyConnectedError();\n      }\n\n      var abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n      (_a = this.abortController) === null || _a === void 0 ? void 0 : _a.abort();\n      this.abortController = abortController;\n\n      if (abortController.signal.aborted) {\n        throw new TonConnectError('Connection was aborted');\n      }\n\n      (_b = this.provider) === null || _b === void 0 ? void 0 : _b.closeConnection();\n      this.provider = this.createProvider(wallet);\n      abortController.signal.addEventListener('abort', function () {\n        var _a;\n\n        (_a = _this40.provider) === null || _a === void 0 ? void 0 : _a.closeConnection();\n        _this40.provider = null;\n      });\n      this.tracker.trackConnectionStarted();\n      return this.provider.connect(this.createConnectRequest(options === null || options === void 0 ? void 0 : options.request), {\n        openingDeadlineMS: options === null || options === void 0 ? void 0 : options.openingDeadlineMS,\n        signal: abortController.signal\n      });\n    }\n    /**\n     * Try to restore existing session and reconnect to the corresponding wallet. Call it immediately when your app is loaded.\n     */\n\n  }, {\n    key: \"restoreConnection\",\n    value: function restoreConnection(options) {\n      var _a, _b;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee65() {\n        var _this41 = this;\n\n        var abortController, _yield$Promise$all, _yield$Promise$all2, bridgeConnectionType, embeddedWallet, provider, onAbortRestore;\n\n        return _regeneratorRuntime.wrap(function _callee65$(_context65) {\n          while (1) {\n            switch (_context65.prev = _context65.next) {\n              case 0:\n                this.tracker.trackConnectionRestoringStarted();\n                abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n                (_a = this.abortController) === null || _a === void 0 ? void 0 : _a.abort();\n                this.abortController = abortController;\n\n                if (!abortController.signal.aborted) {\n                  _context65.next = 7;\n                  break;\n                }\n\n                this.tracker.trackConnectionRestoringError('Connection restoring was aborted');\n                return _context65.abrupt(\"return\");\n\n              case 7:\n                _context65.next = 9;\n                return Promise.all([this.bridgeConnectionStorage.storedConnectionType(), this.walletsList.getEmbeddedWallet()]);\n\n              case 9:\n                _yield$Promise$all = _context65.sent;\n                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n                bridgeConnectionType = _yield$Promise$all2[0];\n                embeddedWallet = _yield$Promise$all2[1];\n\n                if (!abortController.signal.aborted) {\n                  _context65.next = 16;\n                  break;\n                }\n\n                this.tracker.trackConnectionRestoringError('Connection restoring was aborted');\n                return _context65.abrupt(\"return\");\n\n              case 16:\n                provider = null;\n                _context65.prev = 17;\n                _context65.t0 = bridgeConnectionType;\n                _context65.next = _context65.t0 === 'http' ? 21 : _context65.t0 === 'injected' ? 25 : 29;\n                break;\n\n              case 21:\n                _context65.next = 23;\n                return BridgeProvider.fromStorage(this.dappSettings.storage);\n\n              case 23:\n                provider = _context65.sent;\n                return _context65.abrupt(\"break\", 34);\n\n              case 25:\n                _context65.next = 27;\n                return InjectedProvider.fromStorage(this.dappSettings.storage);\n\n              case 27:\n                provider = _context65.sent;\n                return _context65.abrupt(\"break\", 34);\n\n              case 29:\n                if (!embeddedWallet) {\n                  _context65.next = 33;\n                  break;\n                }\n\n                provider = this.createProvider(embeddedWallet);\n                _context65.next = 34;\n                break;\n\n              case 33:\n                return _context65.abrupt(\"return\");\n\n              case 34:\n                _context65.next = 44;\n                break;\n\n              case 36:\n                _context65.prev = 36;\n                _context65.t1 = _context65[\"catch\"](17);\n                this.tracker.trackConnectionRestoringError('Provider is not restored');\n                _context65.next = 41;\n                return this.bridgeConnectionStorage.removeConnection();\n\n              case 41:\n                provider === null || provider === void 0 ? void 0 : provider.closeConnection();\n                provider = null;\n                return _context65.abrupt(\"return\");\n\n              case 44:\n                if (!abortController.signal.aborted) {\n                  _context65.next = 48;\n                  break;\n                }\n\n                provider === null || provider === void 0 ? void 0 : provider.closeConnection();\n                this.tracker.trackConnectionRestoringError('Connection restoring was aborted');\n                return _context65.abrupt(\"return\");\n\n              case 48:\n                if (provider) {\n                  _context65.next = 52;\n                  break;\n                }\n\n                logError('Provider is not restored');\n                this.tracker.trackConnectionRestoringError('Provider is not restored');\n                return _context65.abrupt(\"return\");\n\n              case 52:\n                (_b = this.provider) === null || _b === void 0 ? void 0 : _b.closeConnection();\n                this.provider = provider;\n                provider.listen(this.walletEventsListener.bind(this));\n\n                onAbortRestore = function onAbortRestore() {\n                  _this41.tracker.trackConnectionRestoringError('Connection restoring was aborted');\n\n                  provider === null || provider === void 0 ? void 0 : provider.closeConnection();\n                  provider = null;\n                };\n\n                abortController.signal.addEventListener('abort', onAbortRestore);\n                _context65.next = 59;\n                return callForSuccess(function (_options) {\n                  return __awaiter(_this41, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee64() {\n                    return _regeneratorRuntime.wrap(function _callee64$(_context64) {\n                      while (1) {\n                        switch (_context64.prev = _context64.next) {\n                          case 0:\n                            _context64.next = 2;\n                            return provider === null || provider === void 0 ? void 0 : provider.restoreConnection({\n                              openingDeadlineMS: options === null || options === void 0 ? void 0 : options.openingDeadlineMS,\n                              signal: _options.signal\n                            });\n\n                          case 2:\n                            abortController.signal.removeEventListener('abort', onAbortRestore);\n\n                            if (this.connected) {\n                              this.tracker.trackConnectionRestoringCompleted(this.wallet);\n                            } else {\n                              this.tracker.trackConnectionRestoringError('Connection restoring failed');\n                            }\n\n                          case 4:\n                          case \"end\":\n                            return _context64.stop();\n                        }\n                      }\n                    }, _callee64, this);\n                  }));\n                }, {\n                  attempts: Number.MAX_SAFE_INTEGER,\n                  delayMs: 5000,\n                  signal: options === null || options === void 0 ? void 0 : options.signal\n                });\n\n              case 59:\n                return _context65.abrupt(\"return\", _context65.sent);\n\n              case 60:\n              case \"end\":\n                return _context65.stop();\n            }\n          }\n        }, _callee65, this, [[17, 36]]);\n      }));\n    }\n  }, {\n    key: \"sendTransaction\",\n    value: function sendTransaction(transaction, optionsOrOnRequestSent) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee66() {\n        var options, abortController, validUntil, tx, from, network, response, result;\n        return _regeneratorRuntime.wrap(function _callee66$(_context66) {\n          while (1) {\n            switch (_context66.prev = _context66.next) {\n              case 0:\n                // TODO: remove deprecated method\n                options = {};\n\n                if (typeof optionsOrOnRequestSent === 'function') {\n                  options.onRequestSent = optionsOrOnRequestSent;\n                } else {\n                  options.onRequestSent = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.onRequestSent;\n                  options.signal = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.signal;\n                }\n\n                abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n\n                if (!abortController.signal.aborted) {\n                  _context66.next = 5;\n                  break;\n                }\n\n                throw new TonConnectError('Transaction sending was aborted');\n\n              case 5:\n                this.checkConnection();\n                checkSendTransactionSupport(this.wallet.device.features, {\n                  requiredMessagesNumber: transaction.messages.length\n                });\n                this.tracker.trackTransactionSentForSignature(this.wallet, transaction);\n                validUntil = transaction.validUntil, tx = __rest(transaction, [\"validUntil\"]);\n                from = transaction.from || this.account.address;\n                network = transaction.network || this.account.chain;\n                _context66.next = 13;\n                return this.provider.sendRequest(sendTransactionParser.convertToRpcRequest(Object.assign(Object.assign({}, tx), {\n                  valid_until: validUntil,\n                  from: from,\n                  network: network\n                })), {\n                  onRequestSent: options.onRequestSent,\n                  signal: abortController.signal\n                });\n\n              case 13:\n                response = _context66.sent;\n\n                if (!sendTransactionParser.isError(response)) {\n                  _context66.next = 17;\n                  break;\n                }\n\n                this.tracker.trackTransactionSigningFailed(this.wallet, transaction, response.error.message, response.error.code);\n                return _context66.abrupt(\"return\", sendTransactionParser.parseAndThrowError(response));\n\n              case 17:\n                result = sendTransactionParser.convertFromRpcResponse(response);\n                this.tracker.trackTransactionSigned(this.wallet, transaction, result);\n                return _context66.abrupt(\"return\", result);\n\n              case 20:\n              case \"end\":\n                return _context66.stop();\n            }\n          }\n        }, _callee66, this);\n      }));\n    }\n    /**\n     * Disconnect form thw connected wallet and drop current session.\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect(options) {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee67() {\n        var abortController, prevAbortController;\n        return _regeneratorRuntime.wrap(function _callee67$(_context67) {\n          while (1) {\n            switch (_context67.prev = _context67.next) {\n              case 0:\n                if (this.connected) {\n                  _context67.next = 2;\n                  break;\n                }\n\n                throw new WalletNotConnectedError();\n\n              case 2:\n                abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n                prevAbortController = this.abortController;\n                this.abortController = abortController;\n\n                if (!abortController.signal.aborted) {\n                  _context67.next = 7;\n                  break;\n                }\n\n                throw new TonConnectError('Disconnect was aborted');\n\n              case 7:\n                this.onWalletDisconnected('dapp');\n                _context67.next = 10;\n                return (_a = this.provider) === null || _a === void 0 ? void 0 : _a.disconnect({\n                  signal: abortController.signal\n                });\n\n              case 10:\n                prevAbortController === null || prevAbortController === void 0 ? void 0 : prevAbortController.abort();\n\n              case 11:\n              case \"end\":\n                return _context67.stop();\n            }\n          }\n        }, _callee67, this);\n      }));\n    }\n    /**\n     * Pause bridge HTTP connection. Might be helpful, if you want to pause connections while browser tab is unfocused,\n     * or if you use SDK with NodeJS and want to save server resources.\n     */\n\n  }, {\n    key: \"pauseConnection\",\n    value: function pauseConnection() {\n      var _a;\n\n      if (((_a = this.provider) === null || _a === void 0 ? void 0 : _a.type) !== 'http') {\n        return;\n      }\n\n      this.provider.pause();\n    }\n    /**\n     * Unpause bridge HTTP connection if it is paused.\n     */\n\n  }, {\n    key: \"unPauseConnection\",\n    value: function unPauseConnection() {\n      var _a;\n\n      if (((_a = this.provider) === null || _a === void 0 ? void 0 : _a.type) !== 'http') {\n        return Promise.resolve();\n      }\n\n      return this.provider.unPause();\n    }\n  }, {\n    key: \"addWindowFocusAndBlurSubscriptions\",\n    value: function addWindowFocusAndBlurSubscriptions() {\n      var _this42 = this;\n\n      var document = getDocument();\n\n      if (!document) {\n        return;\n      }\n\n      try {\n        document.addEventListener('visibilitychange', function () {\n          if (document.hidden) {\n            _this42.pauseConnection();\n          } else {\n            _this42.unPauseConnection().catch();\n          }\n        });\n      } catch (e) {\n        logError('Cannot subscribe to the document.visibilitychange: ', e);\n      }\n    }\n  }, {\n    key: \"createProvider\",\n    value: function createProvider(wallet) {\n      var provider;\n\n      if (!Array.isArray(wallet) && isWalletConnectionSourceJS(wallet)) {\n        provider = new InjectedProvider(this.dappSettings.storage, wallet.jsBridgeKey);\n      } else {\n        provider = new BridgeProvider(this.dappSettings.storage, wallet);\n      }\n\n      provider.listen(this.walletEventsListener.bind(this));\n      return provider;\n    }\n  }, {\n    key: \"walletEventsListener\",\n    value: function walletEventsListener(e) {\n      switch (e.event) {\n        case 'connect':\n          this.onWalletConnected(e.payload);\n          break;\n\n        case 'connect_error':\n          this.onWalletConnectError(e.payload);\n          break;\n\n        case 'disconnect':\n          this.onWalletDisconnected('wallet');\n      }\n    }\n  }, {\n    key: \"onWalletConnected\",\n    value: function onWalletConnected(connectEvent) {\n      var tonAccountItem = connectEvent.items.find(function (item) {\n        return item.name === 'ton_addr';\n      });\n      var tonProofItem = connectEvent.items.find(function (item) {\n        return item.name === 'ton_proof';\n      });\n\n      if (!tonAccountItem) {\n        throw new TonConnectError('ton_addr connection item was not found');\n      }\n\n      var wallet = {\n        device: connectEvent.device,\n        provider: this.provider.type,\n        account: {\n          address: tonAccountItem.address,\n          chain: tonAccountItem.network,\n          walletStateInit: tonAccountItem.walletStateInit,\n          publicKey: tonAccountItem.publicKey\n        }\n      };\n\n      if (tonProofItem) {\n        wallet.connectItems = {\n          tonProof: tonProofItem\n        };\n      }\n\n      this.wallet = wallet;\n      this.tracker.trackConnectionCompleted(wallet);\n    }\n  }, {\n    key: \"onWalletConnectError\",\n    value: function onWalletConnectError(connectEventError) {\n      var error = connectErrorsParser.parseError(connectEventError);\n      this.statusChangeErrorSubscriptions.forEach(function (errorsHandler) {\n        return errorsHandler(error);\n      });\n      logDebug(error);\n      this.tracker.trackConnectionError(connectEventError.message, connectEventError.code);\n\n      if (error instanceof ManifestNotFoundError || error instanceof ManifestContentErrorError) {\n        logError(error);\n        throw error;\n      }\n    }\n  }, {\n    key: \"onWalletDisconnected\",\n    value: function onWalletDisconnected(scope) {\n      this.tracker.trackDisconnection(this.wallet, scope);\n      this.wallet = null;\n    }\n  }, {\n    key: \"checkConnection\",\n    value: function checkConnection() {\n      if (!this.connected) {\n        throw new WalletNotConnectedError();\n      }\n    }\n  }, {\n    key: \"createConnectRequest\",\n    value: function createConnectRequest(request) {\n      var items = [{\n        name: 'ton_addr'\n      }];\n\n      if (request === null || request === void 0 ? void 0 : request.tonProof) {\n        items.push({\n          name: 'ton_proof',\n          payload: request.tonProof\n        });\n      }\n\n      return {\n        manifestUrl: this.dappSettings.manifestUrl,\n        items: items\n      };\n    }\n  }], [{\n    key: \"getWallets\",\n    value: function getWallets() {\n      return this.walletsList.getWallets();\n    }\n  }]);\n\n  return TonConnect;\n}();\n\nTonConnect.walletsList = new WalletsListManager();\n/**\n * Check if specified wallet is injected and available to use with the app.\n * @param walletJSKey target wallet's js bridge key.\n */\n\nTonConnect.isWalletInjected = function (walletJSKey) {\n  return InjectedProvider.isWalletInjected(walletJSKey);\n};\n/**\n * Check if the app is opened inside specified wallet's browser.\n * @param walletJSKey target wallet's js bridge key.\n */\n\n\nTonConnect.isInsideWalletBrowser = function (walletJSKey) {\n  return InjectedProvider.isInsideWalletBrowser(walletJSKey);\n};\n\nvar noBounceableTag = 0x51;\nvar testOnlyTag = 0x80;\n/**\n * Converts raw TON address to no-bounceable user-friendly format. [See details]{@link https://ton.org/docs/learn/overviews/addresses#user-friendly-address}\n * @param hexAddress raw TON address formatted as \"0:<hex string without 0x>\".\n * @param [testOnly=false] convert address to test-only form. [See details]{@link https://ton.org/docs/learn/overviews/addresses#user-friendly-address}\n */\n\nfunction toUserFriendlyAddress(hexAddress) {\n  var testOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var _parseHexAddress = parseHexAddress(hexAddress),\n      wc = _parseHexAddress.wc,\n      hex = _parseHexAddress.hex;\n\n  var tag = noBounceableTag;\n\n  if (testOnly) {\n    tag |= testOnlyTag;\n  }\n\n  var addr = new Int8Array(34);\n  addr[0] = tag;\n  addr[1] = wc;\n  addr.set(hex, 2);\n  var addressWithChecksum = new Uint8Array(36);\n  addressWithChecksum.set(addr);\n  addressWithChecksum.set(crc16(addr), 34);\n  var addressBase64 = Base64.encode(addressWithChecksum);\n  return addressBase64.replace(/\\+/g, '-').replace(/\\//g, '_');\n}\n\nfunction parseHexAddress(hexAddress) {\n  if (!hexAddress.includes(':')) {\n    throw new WrongAddressError(\"Wrong address \".concat(hexAddress, \". Address must include \\\":\\\".\"));\n  }\n\n  var parts = hexAddress.split(':');\n\n  if (parts.length !== 2) {\n    throw new WrongAddressError(\"Wrong address \".concat(hexAddress, \". Address must include \\\":\\\" only once.\"));\n  }\n\n  var wc = parseInt(parts[0]);\n\n  if (wc !== 0 && wc !== -1) {\n    throw new WrongAddressError(\"Wrong address \".concat(hexAddress, \". WC must be eq 0 or -1, but \").concat(wc, \" received.\"));\n  }\n\n  var hex = parts[1];\n\n  if ((hex === null || hex === void 0 ? void 0 : hex.length) !== 64) {\n    throw new WrongAddressError(\"Wrong address \".concat(hexAddress, \". Hex part must be 64bytes length, but \").concat(hex === null || hex === void 0 ? void 0 : hex.length, \" received.\"));\n  }\n\n  return {\n    wc: wc,\n    hex: hexToBytes(hex)\n  };\n}\n\nfunction crc16(data) {\n  var poly = 0x1021;\n  var reg = 0;\n  var message = new Uint8Array(data.length + 2);\n  message.set(data);\n\n  var _iterator = _createForOfIteratorHelper(message),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var byte = _step.value;\n      var mask = 0x80;\n\n      while (mask > 0) {\n        reg <<= 1;\n\n        if (byte & mask) {\n          reg += 1;\n        }\n\n        mask >>= 1;\n\n        if (reg > 0xffff) {\n          reg &= 0xffff;\n          reg ^= poly;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return new Uint8Array([Math.floor(reg / 256), reg % 256]);\n}\n\nvar toByteMap = {};\n\nfor (var ord = 0; ord <= 0xff; ord++) {\n  var s = ord.toString(16);\n\n  if (s.length < 2) {\n    s = '0' + s;\n  }\n\n  toByteMap[s] = ord;\n}\n\nfunction hexToBytes(hex) {\n  hex = hex.toLowerCase();\n  var length2 = hex.length;\n\n  if (length2 % 2 !== 0) {\n    throw new ParseHexError('Hex string must have length a multiple of 2: ' + hex);\n  }\n\n  var length = length2 / 2;\n  var result = new Uint8Array(length);\n\n  for (var i = 0; i < length; i++) {\n    var doubled = i * 2;\n    var hexSubstring = hex.substring(doubled, doubled + 2);\n\n    if (!toByteMap.hasOwnProperty(hexSubstring)) {\n      throw new ParseHexError('Invalid hex character: ' + hexSubstring);\n    }\n\n    result[i] = toByteMap[hexSubstring];\n  }\n\n  return result;\n}\n\nexport { BadRequestError, BrowserEventDispatcher, FetchWalletsError, LocalstorageNotFoundError, ParseHexError, TonConnect, TonConnectError, UnknownAppError, UnknownError, UserRejectsError, WalletAlreadyConnectedError, WalletNotConnectedError, WalletNotInjectedError, WalletsListManager, WrongAddressError, createConnectionCompletedEvent, createConnectionErrorEvent, createConnectionRestoringCompletedEvent, createConnectionRestoringErrorEvent, createConnectionRestoringStartedEvent, createConnectionStartedEvent, createDisconnectionEvent, createRequestVersionEvent, createResponseVersionEvent, createTransactionSentForSignatureEvent, createTransactionSignedEvent, createTransactionSigningFailedEvent, createVersionInfo, TonConnect as default, encodeTelegramUrlParameters, isTelegramUrl, isWalletInfoCurrentlyEmbedded, isWalletInfoCurrentlyInjected, isWalletInfoInjectable, isWalletInfoInjected, isWalletInfoRemote, toUserFriendlyAddress }; //# sourceMappingURL=index.mjs.map","map":null,"metadata":{},"sourceType":"module"}