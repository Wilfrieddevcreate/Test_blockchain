{"ast":null,"code":"import _slicedToArray from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { isNone } from '../../animation/utils/is-none.mjs';\nimport { getVariableValue } from './utils/css-variables-conversion.mjs';\nimport { isCSSVariableToken } from './utils/is-css-variable.mjs';\nimport { positionalKeys, isNumOrPxType, positionalValues } from './utils/unit-conversion.mjs';\nimport { findDimensionValueType } from './value-types/dimensions.mjs';\nimport { KeyframeResolver } from '../utils/KeyframesResolver.mjs';\nimport { makeNoneKeyframesAnimatable } from '../html/utils/make-none-animatable.mjs';\n\nvar DOMKeyframesResolver = /*#__PURE__*/function (_KeyframeResolver) {\n  _inherits(DOMKeyframesResolver, _KeyframeResolver);\n\n  var _super = _createSuper(DOMKeyframesResolver);\n\n  function DOMKeyframesResolver(unresolvedKeyframes, onComplete, name, motionValue) {\n    _classCallCheck(this, DOMKeyframesResolver);\n\n    return _super.call(this, unresolvedKeyframes, onComplete, name, motionValue, motionValue === null || motionValue === void 0 ? void 0 : motionValue.owner, true);\n  }\n\n  _createClass(DOMKeyframesResolver, [{\n    key: \"readKeyframes\",\n    value: function readKeyframes() {\n      var unresolvedKeyframes = this.unresolvedKeyframes,\n          element = this.element,\n          name = this.name;\n      if (!element.current) return;\n\n      _get(_getPrototypeOf(DOMKeyframesResolver.prototype), \"readKeyframes\", this).call(this);\n      /**\n       * If any keyframe is a CSS variable, we need to find its value by sampling the element\n       */\n\n\n      for (var i = 0; i < unresolvedKeyframes.length; i++) {\n        var keyframe = unresolvedKeyframes[i];\n\n        if (typeof keyframe === \"string\") {\n          keyframe = keyframe.trim();\n\n          if (isCSSVariableToken(keyframe)) {\n            var resolved = getVariableValue(keyframe, element.current);\n\n            if (resolved !== undefined) {\n              unresolvedKeyframes[i] = resolved;\n            }\n\n            if (i === unresolvedKeyframes.length - 1) {\n              this.finalKeyframe = keyframe;\n            }\n          }\n        }\n      }\n      /**\n       * Resolve \"none\" values. We do this potentially twice - once before and once after measuring keyframes.\n       * This could be seen as inefficient but it's a trade-off to avoid measurements in more situations, which\n       * have a far bigger performance impact.\n       */\n\n\n      this.resolveNoneKeyframes();\n      /**\n       * Check to see if unit type has changed. If so schedule jobs that will\n       * temporarily set styles to the destination keyframes.\n       * Skip if we have more than two keyframes or this isn't a positional value.\n       * TODO: We can throw if there are multiple keyframes and the value type changes.\n       */\n\n      if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {\n        return;\n      }\n\n      var _unresolvedKeyframes = _slicedToArray(unresolvedKeyframes, 2),\n          origin = _unresolvedKeyframes[0],\n          target = _unresolvedKeyframes[1];\n\n      var originType = findDimensionValueType(origin);\n      var targetType = findDimensionValueType(target);\n      /**\n       * Either we don't recognise these value types or we can animate between them.\n       */\n\n      if (originType === targetType) return;\n      /**\n       * If both values are numbers or pixels, we can animate between them by\n       * converting them to numbers.\n       */\n\n      if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {\n        for (var _i = 0; _i < unresolvedKeyframes.length; _i++) {\n          var value = unresolvedKeyframes[_i];\n\n          if (typeof value === \"string\") {\n            unresolvedKeyframes[_i] = parseFloat(value);\n          }\n        }\n      } else {\n        /**\n         * Else, the only way to resolve this is by measuring the element.\n         */\n        this.needsMeasurement = true;\n      }\n    }\n  }, {\n    key: \"resolveNoneKeyframes\",\n    value: function resolveNoneKeyframes() {\n      var unresolvedKeyframes = this.unresolvedKeyframes,\n          name = this.name;\n      var noneKeyframeIndexes = [];\n\n      for (var i = 0; i < unresolvedKeyframes.length; i++) {\n        if (isNone(unresolvedKeyframes[i])) {\n          noneKeyframeIndexes.push(i);\n        }\n      }\n\n      if (noneKeyframeIndexes.length) {\n        makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);\n      }\n    }\n  }, {\n    key: \"measureInitialState\",\n    value: function measureInitialState() {\n      var element = this.element,\n          unresolvedKeyframes = this.unresolvedKeyframes,\n          name = this.name;\n      if (!element.current) return;\n\n      if (name === \"height\") {\n        this.suspendedScrollY = window.pageYOffset;\n      }\n\n      this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n      unresolvedKeyframes[0] = this.measuredOrigin; // Set final key frame to measure after next render\n\n      var measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n\n      if (measureKeyframe !== undefined) {\n        element.getValue(name, measureKeyframe).jump(measureKeyframe, false);\n      }\n    }\n  }, {\n    key: \"measureEndState\",\n    value: function measureEndState() {\n      var _a;\n\n      var element = this.element,\n          name = this.name,\n          unresolvedKeyframes = this.unresolvedKeyframes;\n      if (!element.current) return;\n      var value = element.getValue(name);\n      value && value.jump(this.measuredOrigin, false);\n      var finalKeyframeIndex = unresolvedKeyframes.length - 1;\n      var finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];\n      unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n\n      if (finalKeyframe !== null && this.finalKeyframe === undefined) {\n        this.finalKeyframe = finalKeyframe;\n      } // If we removed transform values, reapply them before the next render\n\n\n      if ((_a = this.removedTransforms) === null || _a === void 0 ? void 0 : _a.length) {\n        this.removedTransforms.forEach(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              unsetTransformName = _ref2[0],\n              unsetTransformValue = _ref2[1];\n\n          element.getValue(unsetTransformName).set(unsetTransformValue);\n        });\n      }\n\n      this.resolveNoneKeyframes();\n    }\n  }]);\n\n  return DOMKeyframesResolver;\n}(KeyframeResolver);\n\nexport { DOMKeyframesResolver };","map":null,"metadata":{},"sourceType":"module"}