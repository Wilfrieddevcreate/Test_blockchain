{"ast":null,"code":"import _toConsumableArray from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { invariant } from './errors.mjs';\nimport { clamp } from './clamp.mjs';\nimport { pipe } from './pipe.mjs';\nimport { progress } from './progress.mjs';\nimport { noop } from './noop.mjs';\nimport { mix } from './mix/index.mjs';\n\nfunction createMixers(output, ease, customMixer) {\n  var mixers = [];\n  var mixerFactory = customMixer || mix;\n  var numMixers = output.length - 1;\n\n  for (var i = 0; i < numMixers; i++) {\n    var mixer = mixerFactory(output[i], output[i + 1]);\n\n    if (ease) {\n      var easingFunction = Array.isArray(ease) ? ease[i] || noop : ease;\n      mixer = pipe(easingFunction, mixer);\n    }\n\n    mixers.push(mixer);\n  }\n\n  return mixers;\n}\n/**\n * Create a function that maps from a numerical input array to a generic output array.\n *\n * Accepts:\n *   - Numbers\n *   - Colors (hex, hsl, hsla, rgb, rgba)\n *   - Complex (combinations of one or more numbers or strings)\n *\n * ```jsx\n * const mixColor = interpolate([0, 1], ['#fff', '#000'])\n *\n * mixColor(0.5) // 'rgba(128, 128, 128, 1)'\n * ```\n *\n * TODO Revist this approach once we've moved to data models for values,\n * probably not needed to pregenerate mixer functions.\n *\n * @public\n */\n\n\nfunction interpolate(input, output) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref$clamp = _ref.clamp,\n      isClamp = _ref$clamp === void 0 ? true : _ref$clamp,\n      ease = _ref.ease,\n      mixer = _ref.mixer;\n\n  var inputLength = input.length;\n  invariant(inputLength === output.length, \"Both input and output ranges must be the same length\");\n  /**\n   * If we're only provided a single input, we can just make a function\n   * that returns the output.\n   */\n\n  if (inputLength === 1) return function () {\n    return output[0];\n  };\n  if (inputLength === 2 && input[0] === input[1]) return function () {\n    return output[1];\n  }; // If input runs highest -> lowest, reverse both arrays\n\n  if (input[0] > input[inputLength - 1]) {\n    input = _toConsumableArray(input).reverse();\n    output = _toConsumableArray(output).reverse();\n  }\n\n  var mixers = createMixers(output, ease, mixer);\n  var numMixers = mixers.length;\n\n  var interpolator = function interpolator(v) {\n    var i = 0;\n\n    if (numMixers > 1) {\n      for (; i < input.length - 2; i++) {\n        if (v < input[i + 1]) break;\n      }\n    }\n\n    var progressInRange = progress(input[i], input[i + 1], v);\n    return mixers[i](progressInRange);\n  };\n\n  return isClamp ? function (v) {\n    return interpolator(clamp(input[0], input[inputLength - 1], v));\n  } : interpolator;\n}\n\nexport { interpolate };","map":null,"metadata":{},"sourceType":"module"}