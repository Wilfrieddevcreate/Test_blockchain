{"ast":null,"code":"import _slicedToArray from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n\nfunction getValueState(visualElement) {\n  var state = [{}, {}];\n  visualElement === null || visualElement === void 0 ? void 0 : visualElement.values.forEach(function (value, key) {\n    state[0][key] = value.get();\n    state[1][key] = value.getVelocity();\n  });\n  return state;\n}\n\nfunction resolveVariantFromProps(props, definition, custom, visualElement) {\n  /**\n   * If the variant definition is a function, resolve.\n   */\n  if (typeof definition === \"function\") {\n    var _getValueState = getValueState(visualElement),\n        _getValueState2 = _slicedToArray(_getValueState, 2),\n        current = _getValueState2[0],\n        velocity = _getValueState2[1];\n\n    definition = definition(custom !== undefined ? custom : props.custom, current, velocity);\n  }\n  /**\n   * If the variant definition is a variant label, or\n   * the function returned a variant label, resolve.\n   */\n\n\n  if (typeof definition === \"string\") {\n    definition = props.variants && props.variants[definition];\n  }\n  /**\n   * At this point we've resolved both functions and variant labels,\n   * but the resolved variant label might itself have been a function.\n   * If so, resolve. This can only have returned a valid target object.\n   */\n\n\n  if (typeof definition === \"function\") {\n    var _getValueState3 = getValueState(visualElement),\n        _getValueState4 = _slicedToArray(_getValueState3, 2),\n        _current = _getValueState4[0],\n        _velocity = _getValueState4[1];\n\n    definition = definition(custom !== undefined ? custom : props.custom, _current, _velocity);\n  }\n\n  return definition;\n}\n\nexport { resolveVariantFromProps };","map":null,"metadata":{},"sourceType":"module"}