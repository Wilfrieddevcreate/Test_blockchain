{"ast":null,"code":"import _classCallCheck from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { observeTimeline } from '../render/dom/scroll/observe.mjs';\nimport { supportsScrollTimeline } from '../render/dom/scroll/supports.mjs';\n\nvar GroupPlaybackControls = /*#__PURE__*/function () {\n  function GroupPlaybackControls(animations) {\n    var _this = this;\n\n    _classCallCheck(this, GroupPlaybackControls);\n\n    // Bound to accomodate common `return animation.stop` pattern\n    this.stop = function () {\n      return _this.runAll(\"stop\");\n    };\n\n    this.animations = animations.filter(Boolean);\n  }\n\n  _createClass(GroupPlaybackControls, [{\n    key: \"then\",\n    value: function then(onResolve, onReject) {\n      return Promise.all(this.animations).then(onResolve).catch(onReject);\n    }\n    /**\n     * TODO: Filter out cancelled or stopped animations before returning\n     */\n\n  }, {\n    key: \"getAll\",\n    value: function getAll(propName) {\n      return this.animations[0][propName];\n    }\n  }, {\n    key: \"setAll\",\n    value: function setAll(propName, newValue) {\n      for (var i = 0; i < this.animations.length; i++) {\n        this.animations[i][propName] = newValue;\n      }\n    }\n  }, {\n    key: \"attachTimeline\",\n    value: function attachTimeline(timeline) {\n      var _this2 = this;\n\n      var cancelAll = this.animations.map(function (animation) {\n        if (supportsScrollTimeline() && animation.attachTimeline) {\n          animation.attachTimeline(timeline);\n        } else {\n          animation.pause();\n          return observeTimeline(function (progress) {\n            animation.time = animation.duration * progress;\n          }, timeline);\n        }\n      });\n      return function () {\n        cancelAll.forEach(function (cancelTimeline, i) {\n          if (cancelTimeline) cancelTimeline();\n\n          _this2.animations[i].stop();\n        });\n      };\n    }\n  }, {\n    key: \"time\",\n    get: function get() {\n      return this.getAll(\"time\");\n    },\n    set: function set(time) {\n      this.setAll(\"time\", time);\n    }\n  }, {\n    key: \"speed\",\n    get: function get() {\n      return this.getAll(\"speed\");\n    },\n    set: function set(speed) {\n      this.setAll(\"speed\", speed);\n    }\n  }, {\n    key: \"duration\",\n    get: function get() {\n      var max = 0;\n\n      for (var i = 0; i < this.animations.length; i++) {\n        max = Math.max(max, this.animations[i].duration);\n      }\n\n      return max;\n    }\n  }, {\n    key: \"runAll\",\n    value: function runAll(methodName) {\n      this.animations.forEach(function (controls) {\n        return controls[methodName]();\n      });\n    }\n  }, {\n    key: \"play\",\n    value: function play() {\n      this.runAll(\"play\");\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      this.runAll(\"pause\");\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      this.runAll(\"cancel\");\n    }\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      this.runAll(\"complete\");\n    }\n  }]);\n\n  return GroupPlaybackControls;\n}();\n\nexport { GroupPlaybackControls };","map":null,"metadata":{},"sourceType":"module"}