{"ast":null,"code":"import _toConsumableArray from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _slicedToArray from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { removeNonTranslationalTransform } from '../dom/utils/unit-conversion.mjs';\nimport { frame } from '../../frameloop/frame.mjs';\nvar toResolve = new Set();\nvar isScheduled = false;\nvar anyNeedsMeasurement = false;\n\nfunction measureAllKeyframes() {\n  if (anyNeedsMeasurement) {\n    var resolversToMeasure = Array.from(toResolve).filter(function (resolver) {\n      return resolver.needsMeasurement;\n    });\n    var elementsToMeasure = new Set(resolversToMeasure.map(function (resolver) {\n      return resolver.element;\n    }));\n    var transformsToRestore = new Map();\n    /**\n     * Write pass\n     * If we're measuring elements we want to remove bounding box-changing transforms.\n     */\n\n    elementsToMeasure.forEach(function (element) {\n      var removedTransforms = removeNonTranslationalTransform(element);\n      if (!removedTransforms.length) return;\n      transformsToRestore.set(element, removedTransforms);\n      element.render();\n    }); // Read\n\n    resolversToMeasure.forEach(function (resolver) {\n      return resolver.measureInitialState();\n    }); // Write\n\n    elementsToMeasure.forEach(function (element) {\n      element.render();\n      var restore = transformsToRestore.get(element);\n\n      if (restore) {\n        restore.forEach(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              key = _ref2[0],\n              value = _ref2[1];\n\n          var _a;\n\n          (_a = element.getValue(key)) === null || _a === void 0 ? void 0 : _a.set(value);\n        });\n      }\n    }); // Read\n\n    resolversToMeasure.forEach(function (resolver) {\n      return resolver.measureEndState();\n    }); // Write\n\n    resolversToMeasure.forEach(function (resolver) {\n      if (resolver.suspendedScrollY !== undefined) {\n        window.scrollTo(0, resolver.suspendedScrollY);\n      }\n    });\n  }\n\n  anyNeedsMeasurement = false;\n  isScheduled = false;\n  toResolve.forEach(function (resolver) {\n    return resolver.complete();\n  });\n  toResolve.clear();\n}\n\nfunction readAllKeyframes() {\n  toResolve.forEach(function (resolver) {\n    resolver.readKeyframes();\n\n    if (resolver.needsMeasurement) {\n      anyNeedsMeasurement = true;\n    }\n  });\n}\n\nfunction flushKeyframeResolvers() {\n  readAllKeyframes();\n  measureAllKeyframes();\n}\n\nvar KeyframeResolver = /*#__PURE__*/function () {\n  function KeyframeResolver(unresolvedKeyframes, onComplete, name, motionValue, element) {\n    var isAsync = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\n    _classCallCheck(this, KeyframeResolver);\n\n    /**\n     * Track whether this resolver has completed. Once complete, it never\n     * needs to attempt keyframe resolution again.\n     */\n    this.isComplete = false;\n    /**\n     * Track whether this resolver is async. If it is, it'll be added to the\n     * resolver queue and flushed in the next frame. Resolvers that aren't going\n     * to trigger read/write thrashing don't need to be async.\n     */\n\n    this.isAsync = false;\n    /**\n     * Track whether this resolver needs to perform a measurement\n     * to resolve its keyframes.\n     */\n\n    this.needsMeasurement = false;\n    /**\n     * Track whether this resolver is currently scheduled to resolve\n     * to allow it to be cancelled and resumed externally.\n     */\n\n    this.isScheduled = false;\n    this.unresolvedKeyframes = _toConsumableArray(unresolvedKeyframes);\n    this.onComplete = onComplete;\n    this.name = name;\n    this.motionValue = motionValue;\n    this.element = element;\n    this.isAsync = isAsync;\n  }\n\n  _createClass(KeyframeResolver, [{\n    key: \"scheduleResolve\",\n    value: function scheduleResolve() {\n      this.isScheduled = true;\n\n      if (this.isAsync) {\n        toResolve.add(this);\n\n        if (!isScheduled) {\n          isScheduled = true;\n          frame.read(readAllKeyframes);\n          frame.resolveKeyframes(measureAllKeyframes);\n        }\n      } else {\n        this.readKeyframes();\n        this.complete();\n      }\n    }\n  }, {\n    key: \"readKeyframes\",\n    value: function readKeyframes() {\n      var unresolvedKeyframes = this.unresolvedKeyframes,\n          name = this.name,\n          element = this.element,\n          motionValue = this.motionValue;\n      /**\n       * If a keyframe is null, we hydrate it either by reading it from\n       * the instance, or propagating from previous keyframes.\n       */\n\n      for (var i = 0; i < unresolvedKeyframes.length; i++) {\n        if (unresolvedKeyframes[i] === null) {\n          /**\n           * If the first keyframe is null, we need to find its value by sampling the element\n           */\n          if (i === 0) {\n            var currentValue = motionValue === null || motionValue === void 0 ? void 0 : motionValue.get();\n            var finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n\n            if (currentValue !== undefined) {\n              unresolvedKeyframes[0] = currentValue;\n            } else if (element && name) {\n              var valueAsRead = element.readValue(name, finalKeyframe);\n\n              if (valueAsRead !== undefined && valueAsRead !== null) {\n                unresolvedKeyframes[0] = valueAsRead;\n              }\n            }\n\n            if (unresolvedKeyframes[0] === undefined) {\n              unresolvedKeyframes[0] = finalKeyframe;\n            }\n\n            if (motionValue && currentValue === undefined) {\n              motionValue.set(unresolvedKeyframes[0]);\n            }\n          } else {\n            unresolvedKeyframes[i] = unresolvedKeyframes[i - 1];\n          }\n        }\n      }\n    }\n  }, {\n    key: \"setFinalKeyframe\",\n    value: function setFinalKeyframe() {}\n  }, {\n    key: \"measureInitialState\",\n    value: function measureInitialState() {}\n  }, {\n    key: \"renderEndStyles\",\n    value: function renderEndStyles() {}\n  }, {\n    key: \"measureEndState\",\n    value: function measureEndState() {}\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      this.isComplete = true;\n      this.onComplete(this.unresolvedKeyframes, this.finalKeyframe);\n      toResolve.delete(this);\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      if (!this.isComplete) {\n        this.isScheduled = false;\n        toResolve.delete(this);\n      }\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      if (!this.isComplete) this.scheduleResolve();\n    }\n  }]);\n\n  return KeyframeResolver;\n}();\n\nexport { KeyframeResolver, flushKeyframeResolvers };","map":null,"metadata":{},"sourceType":"module"}