{"ast":null,"code":"import _slicedToArray from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"defaultTransition\"],\n    _excluded2 = [\"delay\", \"times\", \"type\"];\nimport { createGeneratorEasing } from '../../easing/utils/create-generator-easing.mjs';\nimport { resolveElements } from '../../render/dom/utils/resolve-element.mjs';\nimport { defaultOffset } from '../../utils/offsets/default.mjs';\nimport { fillOffset } from '../../utils/offsets/fill.mjs';\nimport { progress } from '../../utils/progress.mjs';\nimport { secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\nimport { calcNextTime } from './utils/calc-time.mjs';\nimport { addKeyframes } from './utils/edit.mjs';\nimport { compareByTime } from './utils/sort.mjs';\nvar defaultSegmentEasing = \"easeInOut\";\n\nfunction createAnimationsFromSequence(sequence) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$defaultTransitio = _ref.defaultTransition,\n      defaultTransition = _ref$defaultTransitio === void 0 ? {} : _ref$defaultTransitio,\n      sequenceTransition = _objectWithoutProperties(_ref, _excluded);\n\n  var scope = arguments.length > 2 ? arguments[2] : undefined;\n  var defaultDuration = defaultTransition.duration || 0.3;\n  var animationDefinitions = new Map();\n  var sequences = new Map();\n  var elementCache = {};\n  var timeLabels = new Map();\n  var prevTime = 0;\n  var currentTime = 0;\n  var totalDuration = 0;\n  /**\n   * Build the timeline by mapping over the sequence array and converting\n   * the definitions into keyframes and offsets with absolute time values.\n   * These will later get converted into relative offsets in a second pass.\n   */\n\n  var _loop = function _loop(i) {\n    var segment = sequence[i];\n    /**\n     * If this is a timeline label, mark it and skip the rest of this iteration.\n     */\n\n    if (typeof segment === \"string\") {\n      timeLabels.set(segment, currentTime);\n      return \"continue\";\n    } else if (!Array.isArray(segment)) {\n      timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n      return \"continue\";\n    }\n\n    var _segment = _slicedToArray(segment, 3),\n        subject = _segment[0],\n        keyframes = _segment[1],\n        _segment$ = _segment[2],\n        transition = _segment$ === void 0 ? {} : _segment$;\n    /**\n     * If a relative or absolute time value has been specified we need to resolve\n     * it in relation to the currentTime.\n     */\n\n\n    if (transition.at !== undefined) {\n      currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);\n    }\n    /**\n     * Keep track of the maximum duration in this definition. This will be\n     * applied to currentTime once the definition has been parsed.\n     */\n\n\n    var maxDuration = 0;\n\n    var resolveValueSequence = function resolveValueSequence(valueKeyframes, valueTransition, valueSequence) {\n      var elementIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var numElements = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n      var valueKeyframesAsList = keyframesAsList(valueKeyframes);\n\n      var _valueTransition$dela = valueTransition.delay,\n          delay = _valueTransition$dela === void 0 ? 0 : _valueTransition$dela,\n          _valueTransition$time = valueTransition.times,\n          times = _valueTransition$time === void 0 ? defaultOffset(valueKeyframesAsList) : _valueTransition$time,\n          _valueTransition$type = valueTransition.type,\n          type = _valueTransition$type === void 0 ? \"keyframes\" : _valueTransition$type,\n          remainingTransition = _objectWithoutProperties(valueTransition, _excluded2);\n\n      var _valueTransition$ease = valueTransition.ease,\n          ease = _valueTransition$ease === void 0 ? defaultTransition.ease || \"easeOut\" : _valueTransition$ease,\n          duration = valueTransition.duration;\n      /**\n       * Resolve stagger() if defined.\n       */\n\n      var calculatedDelay = typeof delay === \"function\" ? delay(elementIndex, numElements) : delay;\n      /**\n       * If this animation should and can use a spring, generate a spring easing function.\n       */\n\n      var numKeyframes = valueKeyframesAsList.length;\n\n      if (numKeyframes <= 2 && type === \"spring\") {\n        /**\n         * As we're creating an easing function from a spring,\n         * ideally we want to generate it using the real distance\n         * between the two keyframes. However this isn't always\n         * possible - in these situations we use 0-100.\n         */\n        var absoluteDelta = 100;\n\n        if (numKeyframes === 2 && isNumberKeyframesArray(valueKeyframesAsList)) {\n          var delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];\n          absoluteDelta = Math.abs(delta);\n        }\n\n        var springTransition = _objectSpread({}, remainingTransition);\n\n        if (duration !== undefined) {\n          springTransition.duration = secondsToMilliseconds(duration);\n        }\n\n        var springEasing = createGeneratorEasing(springTransition, absoluteDelta);\n        ease = springEasing.ease;\n        duration = springEasing.duration;\n      }\n\n      duration !== null && duration !== void 0 ? duration : duration = defaultDuration;\n      var startTime = currentTime + calculatedDelay;\n      var targetTime = startTime + duration;\n      /**\n       * If there's only one time offset of 0, fill in a second with length 1\n       */\n\n      if (times.length === 1 && times[0] === 0) {\n        times[1] = 1;\n      }\n      /**\n       * Fill out if offset if fewer offsets than keyframes\n       */\n\n\n      var remainder = times.length - valueKeyframesAsList.length;\n      remainder > 0 && fillOffset(times, remainder);\n      /**\n       * If only one value has been set, ie [1], push a null to the start of\n       * the keyframe array. This will let us mark a keyframe at this point\n       * that will later be hydrated with the previous value.\n       */\n\n      valueKeyframesAsList.length === 1 && valueKeyframesAsList.unshift(null);\n      /**\n       * Add keyframes, mapping offsets to absolute time.\n       */\n\n      addKeyframes(valueSequence, valueKeyframesAsList, ease, times, startTime, targetTime);\n      maxDuration = Math.max(calculatedDelay + duration, maxDuration);\n      totalDuration = Math.max(targetTime, totalDuration);\n    };\n\n    if (isMotionValue(subject)) {\n      var subjectSequence = getSubjectSequence(subject, sequences);\n      resolveValueSequence(keyframes, transition, getValueSequence(\"default\", subjectSequence));\n    } else {\n      /**\n       * Find all the elements specified in the definition and parse value\n       * keyframes from their timeline definitions.\n       */\n      var elements = resolveElements(subject, scope, elementCache);\n      var numElements = elements.length;\n      /**\n       * For every element in this segment, process the defined values.\n       */\n\n      for (var elementIndex = 0; elementIndex < numElements; elementIndex++) {\n        /**\n         * Cast necessary, but we know these are of this type\n         */\n        keyframes = keyframes;\n        transition = transition;\n        var element = elements[elementIndex];\n\n        var _subjectSequence = getSubjectSequence(element, sequences);\n\n        for (var key in keyframes) {\n          resolveValueSequence(keyframes[key], getValueTransition(transition, key), getValueSequence(key, _subjectSequence), elementIndex, numElements);\n        }\n      }\n    }\n\n    prevTime = currentTime;\n    currentTime += maxDuration;\n  };\n\n  for (var i = 0; i < sequence.length; i++) {\n    var _ret = _loop(i);\n\n    if (_ret === \"continue\") continue;\n  }\n  /**\n   * For every element and value combination create a new animation.\n   */\n\n\n  sequences.forEach(function (valueSequences, element) {\n    for (var key in valueSequences) {\n      var valueSequence = valueSequences[key];\n      /**\n       * Arrange all the keyframes in ascending time order.\n       */\n\n      valueSequence.sort(compareByTime);\n      var keyframes = [];\n      var valueOffset = [];\n      var valueEasing = [];\n      /**\n       * For each keyframe, translate absolute times into\n       * relative offsets based on the total duration of the timeline.\n       */\n\n      for (var _i = 0; _i < valueSequence.length; _i++) {\n        var _valueSequence$_i = valueSequence[_i],\n            at = _valueSequence$_i.at,\n            value = _valueSequence$_i.value,\n            easing = _valueSequence$_i.easing;\n        keyframes.push(value);\n        valueOffset.push(progress(0, totalDuration, at));\n        valueEasing.push(easing || \"easeOut\");\n      }\n      /**\n       * If the first keyframe doesn't land on offset: 0\n       * provide one by duplicating the initial keyframe. This ensures\n       * it snaps to the first keyframe when the animation starts.\n       */\n\n\n      if (valueOffset[0] !== 0) {\n        valueOffset.unshift(0);\n        keyframes.unshift(keyframes[0]);\n        valueEasing.unshift(defaultSegmentEasing);\n      }\n      /**\n       * If the last keyframe doesn't land on offset: 1\n       * provide one with a null wildcard value. This will ensure it\n       * stays static until the end of the animation.\n       */\n\n\n      if (valueOffset[valueOffset.length - 1] !== 1) {\n        valueOffset.push(1);\n        keyframes.push(null);\n      }\n\n      if (!animationDefinitions.has(element)) {\n        animationDefinitions.set(element, {\n          keyframes: {},\n          transition: {}\n        });\n      }\n\n      var definition = animationDefinitions.get(element);\n      definition.keyframes[key] = keyframes;\n      definition.transition[key] = _objectSpread(_objectSpread({}, defaultTransition), {}, {\n        duration: totalDuration,\n        ease: valueEasing,\n        times: valueOffset\n      }, sequenceTransition);\n    }\n  });\n  return animationDefinitions;\n}\n\nfunction getSubjectSequence(subject, sequences) {\n  !sequences.has(subject) && sequences.set(subject, {});\n  return sequences.get(subject);\n}\n\nfunction getValueSequence(name, sequences) {\n  if (!sequences[name]) sequences[name] = [];\n  return sequences[name];\n}\n\nfunction keyframesAsList(keyframes) {\n  return Array.isArray(keyframes) ? keyframes : [keyframes];\n}\n\nfunction getValueTransition(transition, key) {\n  return transition[key] ? _objectSpread(_objectSpread({}, transition), transition[key]) : _objectSpread({}, transition);\n}\n\nvar isNumber = function isNumber(keyframe) {\n  return typeof keyframe === \"number\";\n};\n\nvar isNumberKeyframesArray = function isNumberKeyframesArray(keyframes) {\n  return keyframes.every(isNumber);\n};\n\nexport { createAnimationsFromSequence, getValueTransition };","map":null,"metadata":{},"sourceType":"module"}